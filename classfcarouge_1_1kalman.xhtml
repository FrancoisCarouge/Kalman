<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kalman: fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kalman<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Kalman Filter for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.xhtml');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classfcarouge_1_1kalman.xhtml',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classfcarouge_1_1kalman-members.xhtml">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A generic Kalman filter for C++23.  
 <a href="classfcarouge_1_1kalman.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classfcarouge_1_1kalman__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Types</div></td></tr>
<tr class="memitem:a1102f87212b368e4e55bcd5d637a600c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> = typename implementation::state</td></tr>
<tr class="memdesc:a1102f87212b368e4e55bcd5d637a600c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">More...</a><br /></td></tr>
<tr class="separator:a1102f87212b368e4e55bcd5d637a600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd585072f9799aa546943934e1a38e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7fd585072f9799aa546943934e1a38e1">output</a> = typename implementation::output</td></tr>
<tr class="memdesc:a7fd585072f9799aa546943934e1a38e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the observation column vector Z.  <a href="classfcarouge_1_1kalman.xhtml#a7fd585072f9799aa546943934e1a38e1">More...</a><br /></td></tr>
<tr class="separator:a7fd585072f9799aa546943934e1a38e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca54b5a1f438d4c6299ac36035450d3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aca54b5a1f438d4c6299ac36035450d3c">input</a> = typename implementation::input</td></tr>
<tr class="memdesc:aca54b5a1f438d4c6299ac36035450d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the control column vector U.  <a href="classfcarouge_1_1kalman.xhtml#aca54b5a1f438d4c6299ac36035450d3c">More...</a><br /></td></tr>
<tr class="separator:aca54b5a1f438d4c6299ac36035450d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15928894f06259752d02d9ee26b2e47e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> = typename implementation::estimate_uncertainty</td></tr>
<tr class="memdesc:a15928894f06259752d02d9ee26b2e47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the estimated correlated variance matrix P.  <a href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">More...</a><br /></td></tr>
<tr class="separator:a15928894f06259752d02d9ee26b2e47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e201e1563f135b128edbf2c9793e56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> = typename implementation::process_uncertainty</td></tr>
<tr class="memdesc:a95e201e1563f135b128edbf2c9793e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the process noise correlated variance matrix Q.  <a href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">More...</a><br /></td></tr>
<tr class="separator:a95e201e1563f135b128edbf2c9793e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fac97289314ad4018774b6afbd73716"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> = typename implementation::output_uncertainty</td></tr>
<tr class="memdesc:a9fac97289314ad4018774b6afbd73716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the observation noise correlated variance matrix R.  <a href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">More...</a><br /></td></tr>
<tr class="separator:a9fac97289314ad4018774b6afbd73716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763d09902667e195848fa899e310beb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> = typename implementation::state_transition</td></tr>
<tr class="memdesc:ab763d09902667e195848fa899e310beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the state transition matrix F.  <a href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">More...</a><br /></td></tr>
<tr class="separator:ab763d09902667e195848fa899e310beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642332d5ad9d1e135bbe5220961de64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> = typename implementation::output_model</td></tr>
<tr class="memdesc:a1642332d5ad9d1e135bbe5220961de64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the observation transition matrix H.  <a href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">More...</a><br /></td></tr>
<tr class="separator:a1642332d5ad9d1e135bbe5220961de64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62d02fbc8be939e05a135b0cec3b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> = typename implementation::input_control</td></tr>
<tr class="memdesc:a59c62d02fbc8be939e05a135b0cec3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the control transition matrix G.  <a href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">More...</a><br /></td></tr>
<tr class="separator:a59c62d02fbc8be939e05a135b0cec3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eeee2aae7756cb1a24350ff802de2a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ad1eeee2aae7756cb1a24350ff802de2a">gain</a> = typename implementation::gain</td></tr>
<tr class="memdesc:ad1eeee2aae7756cb1a24350ff802de2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the gain matrix K.  <a href="classfcarouge_1_1kalman.xhtml#ad1eeee2aae7756cb1a24350ff802de2a">More...</a><br /></td></tr>
<tr class="separator:ad1eeee2aae7756cb1a24350ff802de2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222414fb9c93edb378a0156aa278a811"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a222414fb9c93edb378a0156aa278a811">innovation</a> = typename implementation::innovation</td></tr>
<tr class="memdesc:a222414fb9c93edb378a0156aa278a811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the innovation column vector Y.  <a href="classfcarouge_1_1kalman.xhtml#a222414fb9c93edb378a0156aa278a811">More...</a><br /></td></tr>
<tr class="separator:a222414fb9c93edb378a0156aa278a811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab485e684ce0723c3d6de5dec389c88a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab485e684ce0723c3d6de5dec389c88a6">innovation_uncertainty</a> = typename implementation::innovation_uncertainty</td></tr>
<tr class="memdesc:ab485e684ce0723c3d6de5dec389c88a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the innovation uncertainty matrix S.  <a href="classfcarouge_1_1kalman.xhtml#ab485e684ce0723c3d6de5dec389c88a6">More...</a><br /></td></tr>
<tr class="separator:ab485e684ce0723c3d6de5dec389c88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1985c7ac691e33223b6b470bd7516056"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">observation_state_function</a> = typename implementation::observation_state_function</td></tr>
<tr class="memdesc:a1985c7ac691e33223b6b470bd7516056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable observation state function.  <a href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">More...</a><br /></td></tr>
<tr class="separator:a1985c7ac691e33223b6b470bd7516056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f72ebc552d798c0f1c20198e68127bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">noise_observation_function</a> = typename implementation::noise_observation_function</td></tr>
<tr class="memdesc:a1f72ebc552d798c0f1c20198e68127bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable noise observation function.  <a href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">More...</a><br /></td></tr>
<tr class="separator:a1f72ebc552d798c0f1c20198e68127bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9de840036a999b615535a2399a1667"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">transition_state_function</a> = typename implementation::transition_state_function</td></tr>
<tr class="memdesc:a4b9de840036a999b615535a2399a1667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable transition state function.  <a href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">More...</a><br /></td></tr>
<tr class="separator:a4b9de840036a999b615535a2399a1667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbfed3fa165990b1d2b11b66a8ce5c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">noise_process_function</a> = typename implementation::noise_process_function</td></tr>
<tr class="memdesc:a7bbfed3fa165990b1d2b11b66a8ce5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable noise process function.  <a href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">More...</a><br /></td></tr>
<tr class="separator:a7bbfed3fa165990b1d2b11b66a8ce5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b78edf59992eb0f70a5ac7e929435e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">transition_control_function</a> = typename implementation::transition_control_function</td></tr>
<tr class="memdesc:a78b78edf59992eb0f70a5ac7e929435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable transition control function.  <a href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">More...</a><br /></td></tr>
<tr class="separator:a78b78edf59992eb0f70a5ac7e929435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590bb0d2390025d6e1705dd073450bf8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">transition_function</a> = typename implementation::transition_function</td></tr>
<tr class="memdesc:a590bb0d2390025d6e1705dd073450bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable transition function.  <a href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">More...</a><br /></td></tr>
<tr class="separator:a590bb0d2390025d6e1705dd073450bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689fcc450a7698b5375da9dc9c6a535b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">observation_function</a> = typename implementation::observation_function</td></tr>
<tr class="memdesc:a689fcc450a7698b5375da9dc9c6a535b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callable observation function.  <a href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">More...</a><br /></td></tr>
<tr class="separator:a689fcc450a7698b5375da9dc9c6a535b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a59a9e100ebc62a6d4db11a7e65a06b12"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a59a9e100ebc62a6d4db11a7e65a06b12">kalman</a> ()=default</td></tr>
<tr class="memdesc:a59a9e100ebc62a6d4db11a7e65a06b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a Kalman filter without configuration.  <a href="classfcarouge_1_1kalman.xhtml#a59a9e100ebc62a6d4db11a7e65a06b12">More...</a><br /></td></tr>
<tr class="separator:a59a9e100ebc62a6d4db11a7e65a06b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3064ce3ec5d541ddb849a7b530b5124"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aa3064ce3ec5d541ddb849a7b530b5124">kalman</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;other)=default</td></tr>
<tr class="memdesc:aa3064ce3ec5d541ddb849a7b530b5124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs a filter.  <a href="classfcarouge_1_1kalman.xhtml#aa3064ce3ec5d541ddb849a7b530b5124">More...</a><br /></td></tr>
<tr class="separator:aa3064ce3ec5d541ddb849a7b530b5124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c4057f94bf097d2075c2b019a1a9e5"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a97c4057f94bf097d2075c2b019a1a9e5">kalman</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a97c4057f94bf097d2075c2b019a1a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs a filter.  <a href="classfcarouge_1_1kalman.xhtml#a97c4057f94bf097d2075c2b019a1a9e5">More...</a><br /></td></tr>
<tr class="separator:a97c4057f94bf097d2075c2b019a1a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae5a09664832ca35039c426a4a15cc6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a4ae5a09664832ca35039c426a4a15cc6">operator=</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;other) -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td></tr>
<tr class="memdesc:a4ae5a09664832ca35039c426a4a15cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classfcarouge_1_1kalman.xhtml#a4ae5a09664832ca35039c426a4a15cc6">More...</a><br /></td></tr>
<tr class="separator:a4ae5a09664832ca35039c426a4a15cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f0430be3a57809a6bdca479c341954"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aa2f0430be3a57809a6bdca479c341954">operator=</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td></tr>
<tr class="memdesc:aa2f0430be3a57809a6bdca479c341954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classfcarouge_1_1kalman.xhtml#aa2f0430be3a57809a6bdca479c341954">More...</a><br /></td></tr>
<tr class="separator:aa2f0430be3a57809a6bdca479c341954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc6608c7aa96cd7ea0ab658fd5da54"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aefcc6608c7aa96cd7ea0ab658fd5da54">~kalman</a> ()=default</td></tr>
<tr class="memdesc:aefcc6608c7aa96cd7ea0ab658fd5da54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the kalman filter.  <a href="classfcarouge_1_1kalman.xhtml#aefcc6608c7aa96cd7ea0ab658fd5da54">More...</a><br /></td></tr>
<tr class="separator:aefcc6608c7aa96cd7ea0ab658fd5da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Characteristics Member Functions</div></td></tr>
<tr class="memitem:a283ddb031438dc6b3a9f7c6cadf09338"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a283ddb031438dc6b3a9f7c6cadf09338">x</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;</td></tr>
<tr class="memdesc:a283ddb031438dc6b3a9f7c6cadf09338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a283ddb031438dc6b3a9f7c6cadf09338">More...</a><br /></td></tr>
<tr class="separator:a283ddb031438dc6b3a9f7c6cadf09338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4651ec960a279b0d44df09278ce7f452"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a4651ec960a279b0d44df09278ce7f452">x</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;</td></tr>
<tr class="separator:a4651ec960a279b0d44df09278ce7f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f45fec5e2a499c7874350f27ff16959"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7f45fec5e2a499c7874350f27ff16959">x</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;value)</td></tr>
<tr class="memdesc:a7f45fec5e2a499c7874350f27ff16959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a7f45fec5e2a499c7874350f27ff16959">More...</a><br /></td></tr>
<tr class="separator:a7f45fec5e2a499c7874350f27ff16959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c655b621eaaea59e65cce6abe12dbd7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a0c655b621eaaea59e65cce6abe12dbd7">x</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a0c655b621eaaea59e65cce6abe12dbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a0c655b621eaaea59e65cce6abe12dbd7">More...</a><br /></td></tr>
<tr class="separator:a0c655b621eaaea59e65cce6abe12dbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232d3cdfe6af3eed0cfe3bbfc1a6a51b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a232d3cdfe6af3eed0cfe3bbfc1a6a51b">x</a> (const auto &amp;value, const auto &amp;...values)</td></tr>
<tr class="memdesc:a232d3cdfe6af3eed0cfe3bbfc1a6a51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a232d3cdfe6af3eed0cfe3bbfc1a6a51b">More...</a><br /></td></tr>
<tr class="separator:a232d3cdfe6af3eed0cfe3bbfc1a6a51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f87358de723f8ae31cd0098b54feeb"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a04f87358de723f8ae31cd0098b54feeb">x</a> (auto &amp;&amp;value, auto &amp;&amp;...values)</td></tr>
<tr class="memdesc:a04f87358de723f8ae31cd0098b54feeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state estimate column vector X.  <a href="classfcarouge_1_1kalman.xhtml#a04f87358de723f8ae31cd0098b54feeb">More...</a><br /></td></tr>
<tr class="separator:a04f87358de723f8ae31cd0098b54feeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9171abacab66f3af260de6de99790298"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a9171abacab66f3af260de6de99790298">z</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a7fd585072f9799aa546943934e1a38e1">output</a> &amp;</td></tr>
<tr class="memdesc:a9171abacab66f3af260de6de99790298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last observation column vector Z.  <a href="classfcarouge_1_1kalman.xhtml#a9171abacab66f3af260de6de99790298">More...</a><br /></td></tr>
<tr class="separator:a9171abacab66f3af260de6de99790298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ab6c9d08b0b4b6928363a370fb2c5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a219ab6c9d08b0b4b6928363a370fb2c5">u</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#aca54b5a1f438d4c6299ac36035450d3c">input</a> &amp;requires(not std::is_same_v&lt; Input, void &gt;)</td></tr>
<tr class="memdesc:a219ab6c9d08b0b4b6928363a370fb2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last control column vector U.  <a href="classfcarouge_1_1kalman.xhtml#a219ab6c9d08b0b4b6928363a370fb2c5">More...</a><br /></td></tr>
<tr class="separator:a219ab6c9d08b0b4b6928363a370fb2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86b75da175dc0a7ac9eec5803c92f4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ac86b75da175dc0a7ac9eec5803c92f4b">p</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;</td></tr>
<tr class="memdesc:ac86b75da175dc0a7ac9eec5803c92f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the estimated covariance matrix P.  <a href="classfcarouge_1_1kalman.xhtml#ac86b75da175dc0a7ac9eec5803c92f4b">More...</a><br /></td></tr>
<tr class="separator:ac86b75da175dc0a7ac9eec5803c92f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9742852191b4bb4397e77ffbffafde42"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a9742852191b4bb4397e77ffbffafde42">p</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;</td></tr>
<tr class="separator:a9742852191b4bb4397e77ffbffafde42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922687019e99df6169eb09ddaa396bd7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a922687019e99df6169eb09ddaa396bd7">p</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;value)</td></tr>
<tr class="memdesc:a922687019e99df6169eb09ddaa396bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the estimated covariance matrix P.  <a href="classfcarouge_1_1kalman.xhtml#a922687019e99df6169eb09ddaa396bd7">More...</a><br /></td></tr>
<tr class="separator:a922687019e99df6169eb09ddaa396bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cb329547421eabc8bb91f2c16329b7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ac5cb329547421eabc8bb91f2c16329b7">p</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ac5cb329547421eabc8bb91f2c16329b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the estimated covariance matrix P.  <a href="classfcarouge_1_1kalman.xhtml#ac5cb329547421eabc8bb91f2c16329b7">More...</a><br /></td></tr>
<tr class="separator:ac5cb329547421eabc8bb91f2c16329b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39949781d9f392007b6dbf97d7b5bcab"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a39949781d9f392007b6dbf97d7b5bcab">q</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;</td></tr>
<tr class="memdesc:a39949781d9f392007b6dbf97d7b5bcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process noise covariance matrix Q.  <a href="classfcarouge_1_1kalman.xhtml#a39949781d9f392007b6dbf97d7b5bcab">More...</a><br /></td></tr>
<tr class="separator:a39949781d9f392007b6dbf97d7b5bcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00b60a769d35cb1bb343f759e36143"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#afb00b60a769d35cb1bb343f759e36143">q</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;</td></tr>
<tr class="separator:afb00b60a769d35cb1bb343f759e36143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e4f8a0a73353e11ddebbd1b8d1d82f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a83e4f8a0a73353e11ddebbd1b8d1d82f">q</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;value)</td></tr>
<tr class="memdesc:a83e4f8a0a73353e11ddebbd1b8d1d82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process noise covariance matrix Q.  <a href="classfcarouge_1_1kalman.xhtml#a83e4f8a0a73353e11ddebbd1b8d1d82f">More...</a><br /></td></tr>
<tr class="separator:a83e4f8a0a73353e11ddebbd1b8d1d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5dbe4814f6b42a296c23498010d37f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a3e5dbe4814f6b42a296c23498010d37f">q</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a3e5dbe4814f6b42a296c23498010d37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process noise covariance matrix Q.  <a href="classfcarouge_1_1kalman.xhtml#a3e5dbe4814f6b42a296c23498010d37f">More...</a><br /></td></tr>
<tr class="separator:a3e5dbe4814f6b42a296c23498010d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab318abf09d9bdc76f8b620a005bf89df"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab318abf09d9bdc76f8b620a005bf89df">q</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">noise_process_function</a> &amp;callable)</td></tr>
<tr class="memdesc:ab318abf09d9bdc76f8b620a005bf89df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process noise covariance matrix Q function.  <a href="classfcarouge_1_1kalman.xhtml#ab318abf09d9bdc76f8b620a005bf89df">More...</a><br /></td></tr>
<tr class="separator:ab318abf09d9bdc76f8b620a005bf89df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b29b04611a007b055c3b79c5df93bc3"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a0b29b04611a007b055c3b79c5df93bc3">q</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">noise_process_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a0b29b04611a007b055c3b79c5df93bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process noise covariance matrix Q function.  <a href="classfcarouge_1_1kalman.xhtml#a0b29b04611a007b055c3b79c5df93bc3">More...</a><br /></td></tr>
<tr class="separator:a0b29b04611a007b055c3b79c5df93bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36f348f6a553a23e0ea60be43d70f6a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ad36f348f6a553a23e0ea60be43d70f6a">r</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;</td></tr>
<tr class="memdesc:ad36f348f6a553a23e0ea60be43d70f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observation noise covariance matrix R.  <a href="classfcarouge_1_1kalman.xhtml#ad36f348f6a553a23e0ea60be43d70f6a">More...</a><br /></td></tr>
<tr class="separator:ad36f348f6a553a23e0ea60be43d70f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac11636c2f58e37be2f4c6d90a8f1bfa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aac11636c2f58e37be2f4c6d90a8f1bfa">r</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;</td></tr>
<tr class="separator:aac11636c2f58e37be2f4c6d90a8f1bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2817f91f637370aea02b56fbf076fa01"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a2817f91f637370aea02b56fbf076fa01">r</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;value)</td></tr>
<tr class="memdesc:a2817f91f637370aea02b56fbf076fa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation noise covariance matrix R.  <a href="classfcarouge_1_1kalman.xhtml#a2817f91f637370aea02b56fbf076fa01">More...</a><br /></td></tr>
<tr class="separator:a2817f91f637370aea02b56fbf076fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0619da7600a0124f811314fd2021815"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aa0619da7600a0124f811314fd2021815">r</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:aa0619da7600a0124f811314fd2021815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation noise covariance matrix R.  <a href="classfcarouge_1_1kalman.xhtml#aa0619da7600a0124f811314fd2021815">More...</a><br /></td></tr>
<tr class="separator:aa0619da7600a0124f811314fd2021815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5e5a551e56582d41d2291f68ec85ef"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1d5e5a551e56582d41d2291f68ec85ef">r</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">noise_observation_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a1d5e5a551e56582d41d2291f68ec85ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation noise covariance matrix R function.  <a href="classfcarouge_1_1kalman.xhtml#a1d5e5a551e56582d41d2291f68ec85ef">More...</a><br /></td></tr>
<tr class="separator:a1d5e5a551e56582d41d2291f68ec85ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a5222f56e85a2a03b3de5f735952a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a476a5222f56e85a2a03b3de5f735952a">r</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">noise_observation_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a476a5222f56e85a2a03b3de5f735952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation noise covariance matrix R function.  <a href="classfcarouge_1_1kalman.xhtml#a476a5222f56e85a2a03b3de5f735952a">More...</a><br /></td></tr>
<tr class="separator:a476a5222f56e85a2a03b3de5f735952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe63ffd764a7eef508a9366605038a55"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#afe63ffd764a7eef508a9366605038a55">f</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;</td></tr>
<tr class="memdesc:afe63ffd764a7eef508a9366605038a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state transition matrix F.  <a href="classfcarouge_1_1kalman.xhtml#afe63ffd764a7eef508a9366605038a55">More...</a><br /></td></tr>
<tr class="separator:afe63ffd764a7eef508a9366605038a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0778be5a4f05b18fedc40ae519a4fb6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a0778be5a4f05b18fedc40ae519a4fb6c">f</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;</td></tr>
<tr class="separator:a0778be5a4f05b18fedc40ae519a4fb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36196d86b79b19e6456eb09fedd369"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a0a36196d86b79b19e6456eb09fedd369">f</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;value)</td></tr>
<tr class="memdesc:a0a36196d86b79b19e6456eb09fedd369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state transition matrix F.  <a href="classfcarouge_1_1kalman.xhtml#a0a36196d86b79b19e6456eb09fedd369">More...</a><br /></td></tr>
<tr class="separator:a0a36196d86b79b19e6456eb09fedd369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d4448d3be51931e658b14bea01f2e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a353d4448d3be51931e658b14bea01f2e">f</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a353d4448d3be51931e658b14bea01f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state transition matrix F.  <a href="classfcarouge_1_1kalman.xhtml#a353d4448d3be51931e658b14bea01f2e">More...</a><br /></td></tr>
<tr class="separator:a353d4448d3be51931e658b14bea01f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e051a24d4528313bb9345330eb72c60"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7e051a24d4528313bb9345330eb72c60">f</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">transition_state_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a7e051a24d4528313bb9345330eb72c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state transition matrix F function.  <a href="classfcarouge_1_1kalman.xhtml#a7e051a24d4528313bb9345330eb72c60">More...</a><br /></td></tr>
<tr class="separator:a7e051a24d4528313bb9345330eb72c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1669aec26e10199669598be7515b1b58"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1669aec26e10199669598be7515b1b58">f</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">transition_state_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a1669aec26e10199669598be7515b1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state transition matrix F function.  <a href="classfcarouge_1_1kalman.xhtml#a1669aec26e10199669598be7515b1b58">More...</a><br /></td></tr>
<tr class="separator:a1669aec26e10199669598be7515b1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a696e4880433cce993a10b19887747b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a2a696e4880433cce993a10b19887747b">h</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;</td></tr>
<tr class="memdesc:a2a696e4880433cce993a10b19887747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the observation transition matrix H.  <a href="classfcarouge_1_1kalman.xhtml#a2a696e4880433cce993a10b19887747b">More...</a><br /></td></tr>
<tr class="separator:a2a696e4880433cce993a10b19887747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b74778e3d98fafca60b81b71669d178"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a6b74778e3d98fafca60b81b71669d178">h</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;</td></tr>
<tr class="separator:a6b74778e3d98fafca60b81b71669d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f7ba705650fe606d346969b4542461"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ae4f7ba705650fe606d346969b4542461">h</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;value)</td></tr>
<tr class="memdesc:ae4f7ba705650fe606d346969b4542461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation transition matrix H.  <a href="classfcarouge_1_1kalman.xhtml#ae4f7ba705650fe606d346969b4542461">More...</a><br /></td></tr>
<tr class="separator:ae4f7ba705650fe606d346969b4542461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3890f39ad42f502ced221c523589fb5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ae3890f39ad42f502ced221c523589fb5">h</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ae3890f39ad42f502ced221c523589fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation transition matrix H.  <a href="classfcarouge_1_1kalman.xhtml#ae3890f39ad42f502ced221c523589fb5">More...</a><br /></td></tr>
<tr class="separator:ae3890f39ad42f502ced221c523589fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2040d7e00b06874e5a4ff7bb3385f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a18f2040d7e00b06874e5a4ff7bb3385f">h</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">observation_state_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a18f2040d7e00b06874e5a4ff7bb3385f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation, measurement transition matrix H function.  <a href="classfcarouge_1_1kalman.xhtml#a18f2040d7e00b06874e5a4ff7bb3385f">More...</a><br /></td></tr>
<tr class="separator:a18f2040d7e00b06874e5a4ff7bb3385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d83761a97e6908465a75da1e2ee4da"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a03d83761a97e6908465a75da1e2ee4da">h</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">observation_state_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a03d83761a97e6908465a75da1e2ee4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the observation, measurement transition matrix H function.  <a href="classfcarouge_1_1kalman.xhtml#a03d83761a97e6908465a75da1e2ee4da">More...</a><br /></td></tr>
<tr class="separator:a03d83761a97e6908465a75da1e2ee4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ac9c7640e303e5020ccea0eaf0dfb7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ae3ac9c7640e303e5020ccea0eaf0dfb7">g</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;requires(not std::is_same_v&lt; Input, void &gt;)</td></tr>
<tr class="memdesc:ae3ac9c7640e303e5020ccea0eaf0dfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control transition matrix G.  <a href="classfcarouge_1_1kalman.xhtml#ae3ac9c7640e303e5020ccea0eaf0dfb7">More...</a><br /></td></tr>
<tr class="separator:ae3ac9c7640e303e5020ccea0eaf0dfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa908f8d9ddde01136c44a0f09fb00d5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#afa908f8d9ddde01136c44a0f09fb00d5">g</a> () -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;requires(not std::is_same_v&lt; Input, void &gt;)</td></tr>
<tr class="separator:afa908f8d9ddde01136c44a0f09fb00d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de41e564a10050c0fd7be455045bba6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a3de41e564a10050c0fd7be455045bba6">g</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;value)</td></tr>
<tr class="memdesc:a3de41e564a10050c0fd7be455045bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the control transition matrix G.  <a href="classfcarouge_1_1kalman.xhtml#a3de41e564a10050c0fd7be455045bba6">More...</a><br /></td></tr>
<tr class="separator:a3de41e564a10050c0fd7be455045bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e3d62942b259c347fc03e232f2c297"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ad3e3d62942b259c347fc03e232f2c297">g</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ad3e3d62942b259c347fc03e232f2c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the control transition matrix G.  <a href="classfcarouge_1_1kalman.xhtml#ad3e3d62942b259c347fc03e232f2c297">More...</a><br /></td></tr>
<tr class="separator:ad3e3d62942b259c347fc03e232f2c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f81d84c28af1605363ed9812028dc41"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a8f81d84c28af1605363ed9812028dc41">g</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">transition_control_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a8f81d84c28af1605363ed9812028dc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the control transition matrix G function.  <a href="classfcarouge_1_1kalman.xhtml#a8f81d84c28af1605363ed9812028dc41">More...</a><br /></td></tr>
<tr class="separator:a8f81d84c28af1605363ed9812028dc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c1eb68626e399abf117de538c254b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7c1c1eb68626e399abf117de538c254b">g</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">transition_control_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a7c1c1eb68626e399abf117de538c254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the control transition matrix G function.  <a href="classfcarouge_1_1kalman.xhtml#a7c1c1eb68626e399abf117de538c254b">More...</a><br /></td></tr>
<tr class="separator:a7c1c1eb68626e399abf117de538c254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab8dd1a980bb6a0ec2527ccc0b6370d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a9ab8dd1a980bb6a0ec2527ccc0b6370d">k</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#ad1eeee2aae7756cb1a24350ff802de2a">gain</a> &amp;</td></tr>
<tr class="memdesc:a9ab8dd1a980bb6a0ec2527ccc0b6370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gain matrix K.  <a href="classfcarouge_1_1kalman.xhtml#a9ab8dd1a980bb6a0ec2527ccc0b6370d">More...</a><br /></td></tr>
<tr class="separator:a9ab8dd1a980bb6a0ec2527ccc0b6370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768f798cf2e400312f713434fca71adb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a768f798cf2e400312f713434fca71adb">y</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#a222414fb9c93edb378a0156aa278a811">innovation</a> &amp;</td></tr>
<tr class="memdesc:a768f798cf2e400312f713434fca71adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innovation column vector Y.  <a href="classfcarouge_1_1kalman.xhtml#a768f798cf2e400312f713434fca71adb">More...</a><br /></td></tr>
<tr class="separator:a768f798cf2e400312f713434fca71adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828a776eb386c75dfda49b963b9bd25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a0828a776eb386c75dfda49b963b9bd25">s</a> () const -&gt; const <a class="el" href="classfcarouge_1_1kalman.xhtml#ab485e684ce0723c3d6de5dec389c88a6">innovation_uncertainty</a> &amp;</td></tr>
<tr class="memdesc:a0828a776eb386c75dfda49b963b9bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innovation uncertainty matrix S.  <a href="classfcarouge_1_1kalman.xhtml#a0828a776eb386c75dfda49b963b9bd25">More...</a><br /></td></tr>
<tr class="separator:a0828a776eb386c75dfda49b963b9bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d730d7d70675193158ca059a41ffde0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a3d730d7d70675193158ca059a41ffde0">transition</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">transition_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a3d730d7d70675193158ca059a41ffde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extended state transition function f(x).  <a href="classfcarouge_1_1kalman.xhtml#a3d730d7d70675193158ca059a41ffde0">More...</a><br /></td></tr>
<tr class="separator:a3d730d7d70675193158ca059a41ffde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c28d25749406338e2895dbad5c0158"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a79c28d25749406338e2895dbad5c0158">transition</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">transition_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a79c28d25749406338e2895dbad5c0158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extended state transition function f(x).  <a href="classfcarouge_1_1kalman.xhtml#a79c28d25749406338e2895dbad5c0158">More...</a><br /></td></tr>
<tr class="separator:a79c28d25749406338e2895dbad5c0158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8322a989123873c88190f4dd7cea40a5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a8322a989123873c88190f4dd7cea40a5">observation</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">observation_function</a> &amp;callable)</td></tr>
<tr class="memdesc:a8322a989123873c88190f4dd7cea40a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extended state observation function h(x).  <a href="classfcarouge_1_1kalman.xhtml#a8322a989123873c88190f4dd7cea40a5">More...</a><br /></td></tr>
<tr class="separator:a8322a989123873c88190f4dd7cea40a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee8dab54e2cf6b78bf52551c988bf5"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a2eee8dab54e2cf6b78bf52551c988bf5">observation</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">observation_function</a> &amp;&amp;callable)</td></tr>
<tr class="memdesc:a2eee8dab54e2cf6b78bf52551c988bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the extended state observation function h(x).  <a href="classfcarouge_1_1kalman.xhtml#a2eee8dab54e2cf6b78bf52551c988bf5">More...</a><br /></td></tr>
<tr class="separator:a2eee8dab54e2cf6b78bf52551c988bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Filtering Member Functions</div></td></tr>
<tr class="memitem:a326b305473fba0a1efc17660c94eb199"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a326b305473fba0a1efc17660c94eb199">predict</a> (const auto &amp;...arguments)</td></tr>
<tr class="memdesc:a326b305473fba0a1efc17660c94eb199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces estimates of the state variables and uncertainties.  <a href="classfcarouge_1_1kalman.xhtml#a326b305473fba0a1efc17660c94eb199">More...</a><br /></td></tr>
<tr class="separator:a326b305473fba0a1efc17660c94eb199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1d96672e7eea0d0b7c53c21eaf6f90"><td class="memTemplParams" colspan="2">template&lt;std::size_t Position&gt; </td></tr>
<tr class="memitem:aec1d96672e7eea0d0b7c53c21eaf6f90"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#aec1d96672e7eea0d0b7c53c21eaf6f90">predict</a> () const</td></tr>
<tr class="memdesc:aec1d96672e7eea0d0b7c53c21eaf6f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Nth prediction argument.  <a href="classfcarouge_1_1kalman.xhtml#aec1d96672e7eea0d0b7c53c21eaf6f90">More...</a><br /></td></tr>
<tr class="separator:aec1d96672e7eea0d0b7c53c21eaf6f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b11bb6c9a898533dfd86ce6eef5c20"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a71b11bb6c9a898533dfd86ce6eef5c20">update</a> (const auto &amp;...arguments)</td></tr>
<tr class="memdesc:a71b11bb6c9a898533dfd86ce6eef5c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the estimates with the outcome of a measurement.  <a href="classfcarouge_1_1kalman.xhtml#a71b11bb6c9a898533dfd86ce6eef5c20">More...</a><br /></td></tr>
<tr class="separator:a71b11bb6c9a898533dfd86ce6eef5c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb0ab5cffd71944ac83f19d5f3b3c83"><td class="memTemplParams" colspan="2">template&lt;std::size_t Position&gt; </td></tr>
<tr class="memitem:a8bb0ab5cffd71944ac83f19d5f3b3c83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a8bb0ab5cffd71944ac83f19d5f3b3c83">update</a> () const</td></tr>
<tr class="memdesc:a8bb0ab5cffd71944ac83f19d5f3b3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Nth update argument.  <a href="classfcarouge_1_1kalman.xhtml#a8bb0ab5cffd71944ac83f19d5f3b3c83">More...</a><br /></td></tr>
<tr class="separator:a8bb0ab5cffd71944ac83f19d5f3b3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Types</div></td></tr>
<tr class="memitem:ab36b602d354fad0d0d0aa93abcdd9f01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab36b602d354fad0d0d0aa93abcdd9f01">implementation</a> = internal::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, <a class="el" href="namespacefcarouge_1_1internal.xhtml#a567d18fbfbf6f8d1543bca57ba706f22">internal::repack_t</a>&lt; UpdateTypes &gt;, <a class="el" href="namespacefcarouge_1_1internal.xhtml#a567d18fbfbf6f8d1543bca57ba706f22">internal::repack_t</a>&lt; PredictionTypes &gt; &gt;</td></tr>
<tr class="memdesc:ab36b602d354fad0d0d0aa93abcdd9f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the filter.  <a href="classfcarouge_1_1kalman.xhtml#ab36b602d354fad0d0d0aa93abcdd9f01">More...</a><br /></td></tr>
<tr class="separator:ab36b602d354fad0d0d0aa93abcdd9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:a642727d695ea4a1fee490ff7dd6ad7f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab36b602d354fad0d0d0aa93abcdd9f01">implementation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a></td></tr>
<tr class="memdesc:a642727d695ea4a1fee490ff7dd6ad7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the implementation details of the filter.  <a href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">More...</a><br /></td></tr>
<tr class="separator:a642727d695ea4a1fee490ff7dd6ad7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename State = double, typename Output = double, typename Input = void, typename Transpose = std::identity, typename Symmetrize = std::identity, typename Divide = std::divides&lt;void&gt;, typename Identity = identity_matrix, typename UpdateTypes = empty_pack, typename PredictionTypes = empty_pack&gt;<br />
class fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;</div><p >A generic Kalman filter for C++23. </p>
<p >A Bayesian filter that uses multivariate Gaussians, a recursive state estimator, and a linear quadratic estimator (LQE). A control theory tool applicable to signal estimation, sensor fusion, or data assimilation problems.</p>
<p >Simple and extended filters are supported. The update equation uses the Joseph form. Control input is supported. Various customization point objects allow for using different linear algebra backends for which standard or Eigen3 implementation is provided.</p>
<p >The Kalman filter is applicable for unimodal and uncorrelated uncertainties. The filter assumes white noise, propagation and measurement functions are differentiable, and that the uncertainty stays centered on the state estimate. The filter is the optimal linear filter under assumptions. The filter updates estimates by multiplying Gaussians and predicts estimates by adding Gaussians.</p>
<p >Designing a filter is as much art as science. Design the state (X, P), the process (F, Q), the measurement (Z, R), the measurement function H, and if the system has control inputs (U, B).</p>
<p >Arbitrary parameters can be added to the prediction and update stages to participate in gain-scheduling or linear parameter varying (LPV) systems.</p>
<p >Filters with <code>state x output x input</code> dimensions as 1x1x1 and 1x1x0 (no input) are supported through the Standard Templated Library (STL). Higher dimension filters require Eigen 3 support.</p>
<p >Standard formatter specialization provided for representation of the filter states.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">State</td><td>The type template parameter of the state column vector x. State variables can be observed (measured), or hidden variables (inferred). This is the the mean of the multivariate Gaussian. Defaults to <code>double</code>. </td></tr>
    <tr><td class="paramname">Output</td><td>The type template parameter of the measurement column vector z. Defaults to <code>double</code>. </td></tr>
    <tr><td class="paramname">Input</td><td>The type template parameter of the control u. A <code>void</code> input type can be used for systems with no input control to disable all of the input control features, the control transition matrix G support, and the other related computations from the filter. Defaults to <code>void</code>. </td></tr>
    <tr><td class="paramname">Transpose</td><td>The customization point object template parameter of the matrix transpose functor. Defaults to the standard passthrough <code>std::identity</code> function object since the transposed value of an arithmetic type is itself. </td></tr>
    <tr><td class="paramname">Symmetrize</td><td>The customization point object template parameter of the matrix symmetrization functor. Defaults to the standard passthrough <code>std::identity</code> function object since the symmetric value of an arithmetic type is itself. </td></tr>
    <tr><td class="paramname">Divide</td><td>The customization point object template parameter of the matrix division functor. Default to the standard division <code>std::divides&lt;void&gt;</code> function object. </td></tr>
    <tr><td class="paramname">Identity</td><td>The customization point object template parameter of the matrix identity functor. Defaults to an <code><a class="el" href="structfcarouge_1_1identity__matrix.xhtml" title="Function object for providing an identity matrix.">identity_matrix</a></code> function object returning the arithmetic <code>1</code> value. </td></tr>
    <tr><td class="paramname">UpdateTypes</td><td>The additional update function parameter types passed in through a tuple-like parameter type, composing zero or more types. Parameters such as delta times, variances, or linearized values. The parameters are propagated to the function objects used to compute the state observation H and the observation noise R matrices. The parameters are also propagated to the state observation function object h. Defaults to no parameter types, the empty pack. </td></tr>
    <tr><td class="paramname">PredictionTypes</td><td>The additional prediction function parameter types passed in through a tuple-like parameter type, composing zero or more types. Parameters such as delta times, variances, or linearized values. The parameters are propagated to the function objects used to compute the process noise Q, the state transition F, and the control transition G matrices. The parameters are also propagated to the state transition function object f. Defaults to no parameter types, the empty pack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This class could be usable in constant expressions if <code>std::function</code> could too. The polymorphic function wrapper was used in place of function pointers to enable default initialization from this class, captured member variables.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000016">Todo:</a></b></dt><dd><p class="startdd">Is this filter restricted to Newton's equations of motion? That is only a discretized continuous-time kinematic filter? How about non-Newtonian systems? </p>
<p class="interdd">Would it be beneficial to support initialization list for characteristics? </p>
<p class="interdd">Symmetrization support might be superfluous. How to confirm it is safe to remove? </p>
<p class="interdd">Would we want to support smoothers? </p>
<p class="interdd">How to add or associate constraints on the types and operation to support compilation and semantics? </p>
<p class="interdd">Which constructors to support? Consider constructors? CTAD? Guides? </p>
<p class="interdd">Prepare support for larger dataset recording for graphing, metrics of large test data to facilitate tuning. </p>
<p class="interdd">Support filter generator? Integration? Reflection in C++... </p>
<p class="interdd">Compare performance of general filter with its equivalent generated? </p>
<p class="interdd">Support ranges operator filter? </p>
<p class="interdd">Support mux pipes <a href="https://github.com/joboccara/pipes">https://github.com/joboccara/pipes</a> operator filter? </p>
<p class="interdd">Reproduce Ardupilot's inertial navigation EKF and comparison benchmarks in SITL (software in the loop simulation). </p>
<p class="interdd">Should we provide the operator[] for the vector characteristics regardless of implementation? And for the matrix ones too? It could simplify client code. </p>
<p class="interdd">Should we provide the operator[] for state directly on the filter? Is the state X always what the user would want? </p>
<p class="interdd">Consider if a fluent interface would be preferable for characteristics? </p>
<p class="interdd">Consider additional characteristics method overloads? </p>
<p class="interdd">A clear or reset member equivalent may be useful for real-time re-initializations but to what default? </p>
<p class="interdd">Expand std::format support with standard arguments and Eigen3 types. </p>
<p class="interdd">Support, test complex number filters? </p>
<p class="interdd">Use automatic (Eigen::AutoDiffScalar?), symbolic, numerical solvers to define the filter characteristics and simplify solving the dynamic system for non-mathematicians. </p>
<p class="interdd">Support, use "Taking Static Type-Safety to the Next Level - Physical
Units for Matrices" by Daniel Withopf and record the lesson learned: both usage and development is harder without compile time units verification. </p>
<p class="enddd">Should we add back the call operator? How to resolve the update/predict ordering? And parameter ordering? </p>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="kf_1x1x1_dog_position_8cpp-example.xhtml#_a2">kf_1x1x1_dog_position.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00201">201</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a15928894f06259752d02d9ee26b2e47e" name="a15928894f06259752d02d9ee26b2e47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15928894f06259752d02d9ee26b2e47e">&#9670;&nbsp;</a></span>estimate_uncertainty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::estimate_uncertainty =  typename implementation::estimate_uncertainty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the estimated correlated variance matrix P. </p>
<p >Also known as Σ. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a2">ekf_4x1x0_ardupilot_soaring.cpp</a>, <a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a2">kf_2x1x1_rocket_altitude.cpp</a>, <a class="el" href="kf_6x2x0_vehicle_location_8cpp-example.xhtml#a2">kf_6x2x0_vehicle_location.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a3">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00245">245</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="ad1eeee2aae7756cb1a24350ff802de2a" name="ad1eeee2aae7756cb1a24350ff802de2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eeee2aae7756cb1a24350ff802de2a">&#9670;&nbsp;</a></span>gain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::gain =  typename implementation::gain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the gain matrix K. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00271">271</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="ab36b602d354fad0d0d0aa93abcdd9f01" name="ab36b602d354fad0d0d0aa93abcdd9f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36b602d354fad0d0d0aa93abcdd9f01">&#9670;&nbsp;</a></span>implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::implementation =  internal::kalman&lt;State, Output, Input, Transpose, Symmetrize, Divide, Identity, <a class="el" href="namespacefcarouge_1_1internal.xhtml#a567d18fbfbf6f8d1543bca57ba706f22">internal::repack_t</a>&lt;UpdateTypes&gt;, <a class="el" href="namespacefcarouge_1_1internal.xhtml#a567d18fbfbf6f8d1543bca57ba706f22">internal::repack_t</a>&lt;PredictionTypes&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation details of the filter. </p>
<p >The internal implementation unpacks the parameter packs from tuple-like types which allows for multiple parameter pack deductions. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00210">210</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a222414fb9c93edb378a0156aa278a811" name="a222414fb9c93edb378a0156aa278a811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222414fb9c93edb378a0156aa278a811">&#9670;&nbsp;</a></span>innovation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::innovation =  typename implementation::innovation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the innovation column vector Y. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00274">274</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="ab485e684ce0723c3d6de5dec389c88a6" name="ab485e684ce0723c3d6de5dec389c88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab485e684ce0723c3d6de5dec389c88a6">&#9670;&nbsp;</a></span>innovation_uncertainty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::innovation_uncertainty =  typename implementation::innovation_uncertainty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the innovation uncertainty matrix S. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00277">277</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="aca54b5a1f438d4c6299ac36035450d3c" name="aca54b5a1f438d4c6299ac36035450d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca54b5a1f438d4c6299ac36035450d3c">&#9670;&nbsp;</a></span>input</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::input =  typename implementation::input</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the control column vector U. </p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000017">Todo:</a></b></dt><dd>Conditionally remove this member type when no input is present. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a5">kf_2x1x1_rocket_altitude.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00240">240</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a59c62d02fbc8be939e05a135b0cec3b8" name="a59c62d02fbc8be939e05a135b0cec3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62d02fbc8be939e05a135b0cec3b8">&#9670;&nbsp;</a></span>input_control</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::input_control =  typename implementation::input_control</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the control transition matrix G. </p>
<p >Also known as B.</p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000018">Todo:</a></b></dt><dd>Conditionally remove this member type when no input is present. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a7">kf_2x1x1_rocket_altitude.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00268">268</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a1f72ebc552d798c0f1c20198e68127bc" name="a1f72ebc552d798c0f1c20198e68127bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f72ebc552d798c0f1c20198e68127bc">&#9670;&nbsp;</a></span>noise_observation_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::noise_observation_function =  typename implementation::noise_observation_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable noise observation function. </p>
<p >The function is of the form <code>output_uncertainty(const state &amp;,
const output &amp;, const UpdateTypes &amp;...)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00291">291</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a7bbfed3fa165990b1d2b11b66a8ce5c2" name="a7bbfed3fa165990b1d2b11b66a8ce5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbfed3fa165990b1d2b11b66a8ce5c2">&#9670;&nbsp;</a></span>noise_process_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::noise_process_function =  typename implementation::noise_process_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable noise process function. </p>
<p >The function is of the form <code>process_uncertainty(const state &amp;,
const PredictionTypes &amp;...)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00305">305</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a689fcc450a7698b5375da9dc9c6a535b" name="a689fcc450a7698b5375da9dc9c6a535b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689fcc450a7698b5375da9dc9c6a535b">&#9670;&nbsp;</a></span>observation_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::observation_function =  typename implementation::observation_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable observation function. </p>
<p >The function is of the form <code>output(const state &amp;, const
UpdateTypes &amp;...arguments)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00327">327</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a1985c7ac691e33223b6b470bd7516056" name="a1985c7ac691e33223b6b470bd7516056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1985c7ac691e33223b6b470bd7516056">&#9670;&nbsp;</a></span>observation_state_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::observation_state_function =  typename implementation::observation_state_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable observation state function. </p>
<p >The function is of the form <code>output_model(const state &amp;, const
UpdateTypes &amp;...)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00284">284</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a7fd585072f9799aa546943934e1a38e1" name="a7fd585072f9799aa546943934e1a38e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd585072f9799aa546943934e1a38e1">&#9670;&nbsp;</a></span>output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::output =  typename implementation::output</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the observation column vector Z. </p>
<p >Also known as Y or O. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a6">ekf_4x1x0_ardupilot_soaring.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a2">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00235">235</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a1642332d5ad9d1e135bbe5220961de64" name="a1642332d5ad9d1e135bbe5220961de64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1642332d5ad9d1e135bbe5220961de64">&#9670;&nbsp;</a></span>output_model</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::output_model =  typename implementation::output_model</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the observation transition matrix H. </p>
<p >Also known as the measurement transition matrix or C. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a7">ekf_4x1x0_ardupilot_soaring.cpp</a>, <a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a8">kf_2x1x1_rocket_altitude.cpp</a>, <a class="el" href="kf_6x2x0_vehicle_location_8cpp-example.xhtml#a5">kf_6x2x0_vehicle_location.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a7">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00261">261</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a9fac97289314ad4018774b6afbd73716" name="a9fac97289314ad4018774b6afbd73716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fac97289314ad4018774b6afbd73716">&#9670;&nbsp;</a></span>output_uncertainty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::output_uncertainty =  typename implementation::output_uncertainty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the observation noise correlated variance matrix R. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a5">ekf_4x1x0_ardupilot_soaring.cpp</a>, <a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a9">kf_2x1x1_rocket_altitude.cpp</a>, <a class="el" href="kf_6x2x0_vehicle_location_8cpp-example.xhtml#a6">kf_6x2x0_vehicle_location.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a8">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00251">251</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a95e201e1563f135b128edbf2c9793e56" name="a95e201e1563f135b128edbf2c9793e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e201e1563f135b128edbf2c9793e56">&#9670;&nbsp;</a></span>process_uncertainty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::process_uncertainty =  typename implementation::process_uncertainty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the process noise correlated variance matrix Q. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a4">ekf_4x1x0_ardupilot_soaring.cpp</a>, <a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a4">kf_2x1x1_rocket_altitude.cpp</a>, <a class="el" href="kf_6x2x0_vehicle_location_8cpp-example.xhtml#a3">kf_6x2x0_vehicle_location.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a6">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00248">248</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a1102f87212b368e4e55bcd5d637a600c" name="a1102f87212b368e4e55bcd5d637a600c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102f87212b368e4e55bcd5d637a600c">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::state =  typename implementation::state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the state estimate column vector X. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ekf_4x1x0_ardupilot_soaring_8cpp-example.xhtml#a3">ekf_4x1x0_ardupilot_soaring.cpp</a>, <a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a3">kf_2x1x1_rocket_altitude.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a5">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00230">230</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="ab763d09902667e195848fa899e310beb" name="ab763d09902667e195848fa899e310beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab763d09902667e195848fa899e310beb">&#9670;&nbsp;</a></span>state_transition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::state_transition =  typename implementation::state_transition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the state transition matrix F. </p>
<p >Also known as the fundamental matrix, propagation, Φ, or A. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="kf_2x1x1_rocket_altitude_8cpp-example.xhtml#a6">kf_2x1x1_rocket_altitude.cpp</a>, <a class="el" href="kf_6x2x0_vehicle_location_8cpp-example.xhtml#a4">kf_6x2x0_vehicle_location.cpp</a>, and <a class="el" href="kf_8x4x0_deep_sort_bounding_box_8cpp-example.xhtml#a4">kf_8x4x0_deep_sort_bounding_box.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00256">256</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a78b78edf59992eb0f70a5ac7e929435e" name="a78b78edf59992eb0f70a5ac7e929435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b78edf59992eb0f70a5ac7e929435e">&#9670;&nbsp;</a></span>transition_control_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition_control_function =  typename implementation::transition_control_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable transition control function. </p>
<p >The function is of the form <code>input_control(const PredictionTypes
&amp;...)</code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000019">Todo:</a></b></dt><dd>Conditionally remove this member type when no input is present. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00314">314</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a590bb0d2390025d6e1705dd073450bf8" name="a590bb0d2390025d6e1705dd073450bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590bb0d2390025d6e1705dd073450bf8">&#9670;&nbsp;</a></span>transition_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition_function =  typename implementation::transition_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable transition function. </p>
<p >The function is of the form <code>state(const state &amp;, const input &amp;,
const PredictionTypes &amp;...)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00321">321</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<a id="a4b9de840036a999b615535a2399a1667" name="a4b9de840036a999b615535a2399a1667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9de840036a999b615535a2399a1667">&#9670;&nbsp;</a></span>transition_state_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition_state_function =  typename implementation::transition_state_function</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callable transition state function. </p>
<p >The function is of the form <code>state_transition(const state &amp;,
const input &amp;, const PredictionTypes &amp;...)</code>. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00298">298</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59a9e100ebc62a6d4db11a7e65a06b12" name="a59a9e100ebc62a6d4db11a7e65a06b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a9e100ebc62a6d4db11a7e65a06b12">&#9670;&nbsp;</a></span>kalman() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::kalman </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a Kalman filter without configuration. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa3064ce3ec5d541ddb849a7b530b5124" name="aa3064ce3ec5d541ddb849a7b530b5124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3064ce3ec5d541ddb849a7b530b5124">&#9670;&nbsp;</a></span>kalman() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::kalman </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs a filter. </p>
<p >Constructs the filter with the copy of the contents of the <code>other</code> filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a97c4057f94bf097d2075c2b019a1a9e5" name="a97c4057f94bf097d2075c2b019a1a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c4057f94bf097d2075c2b019a1a9e5">&#9670;&nbsp;</a></span>kalman() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::kalman </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs a filter. </p>
<p >Move constructor. Constructs the filter with the contents of the <code>other</code> filter using move semantics (i.e. the data in <code>other</code> filter is moved from the other into this filter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aefcc6608c7aa96cd7ea0ab658fd5da54" name="aefcc6608c7aa96cd7ea0ab658fd5da54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcc6608c7aa96cd7ea0ab658fd5da54">&#9670;&nbsp;</a></span>~kalman()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::~<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the kalman filter. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0778be5a4f05b18fedc40ae519a4fb6c" name="a0778be5a4f05b18fedc40ae519a4fb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0778be5a4f05b18fedc40ae519a4fb6c">&#9670;&nbsp;</a></span>f() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01136">1136</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1136</span>                                                              {</div>
<div class="line"><span class="lineno"> 1137</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.f;</div>
<div class="line"><span class="lineno"> 1138</span>}</div>
<div class="ttc" id="aclassfcarouge_1_1kalman_xhtml_a642727d695ea4a1fee490ff7dd6ad7f8"><div class="ttname"><a href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">fcarouge::kalman::filter</a></div><div class="ttdeci">implementation filter</div><div class="ttdoc">Encapsulates the implementation details of the filter.</div><div class="ttdef"><b>Definition:</b> <a href="kalman_8hpp_source.xhtml#l00221">kalman.hpp:221</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="afe63ffd764a7eef508a9366605038a55" name="afe63ffd764a7eef508a9366605038a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe63ffd764a7eef508a9366605038a55">&#9670;&nbsp;</a></span>f() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the state transition matrix F. </p>
<dl class="section return"><dt>Returns</dt><dd>The state transition matrix F.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01126">1126</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1126</span>                                                                          {</div>
<div class="line"><span class="lineno"> 1127</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.f;</div>
<div class="line"><span class="lineno"> 1128</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a0a36196d86b79b19e6456eb09fedd369" name="a0a36196d86b79b19e6456eb09fedd369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a36196d86b79b19e6456eb09fedd369">&#9670;&nbsp;</a></span>f() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state transition matrix F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied state transition matrix F.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01145">1145</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1145</span>                                                                     {</div>
<div class="line"><span class="lineno"> 1146</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.f = value;</div>
<div class="line"><span class="lineno"> 1147</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a7e051a24d4528313bb9345330eb72c60" name="a7e051a24d4528313bb9345330eb72c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e051a24d4528313bb9345330eb72c60">&#9670;&nbsp;</a></span>f() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">transition_state_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state transition matrix F function. </p>
<p >For non-linear system, or extended filter, F is the Jacobian of the state transition function: <code>F = ∂f/∂X = ∂fj/∂xi</code> that is each row i contains the derivatives of the state transition function for every element j in the state column vector X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the state transition matrix F function on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01163">1163</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1164</span>                                                       {</div>
<div class="line"><span class="lineno"> 1165</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition_state_f = callable;</div>
<div class="line"><span class="lineno"> 1166</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a353d4448d3be51931e658b14bea01f2e" name="a353d4448d3be51931e658b14bea01f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353d4448d3be51931e658b14bea01f2e">&#9670;&nbsp;</a></span>f() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab763d09902667e195848fa899e310beb">state_transition</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state transition matrix F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved state transition matrix F.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01154">1154</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1154</span>                                                                {</div>
<div class="line"><span class="lineno"> 1155</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.f = std::move(value);</div>
<div class="line"><span class="lineno"> 1156</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a1669aec26e10199669598be7515b1b58" name="a1669aec26e10199669598be7515b1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1669aec26e10199669598be7515b1b58">&#9670;&nbsp;</a></span>f() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a4b9de840036a999b615535a2399a1667">transition_state_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state transition matrix F function. </p>
<p >For non-linear system, or extended filter, F is the Jacobian of the state transition function: <code>F = ∂f/∂X = ∂fj/∂xi</code> that is each row i contains the derivatives of the state transition function for every element j in the state column vector X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the state transition matrix F function on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01173">1173</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1173</span>                                                                            {</div>
<div class="line"><span class="lineno"> 1174</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition_state_f = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1175</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="afa908f8d9ddde01136c44a0f09fb00d5" name="afa908f8d9ddde01136c44a0f09fb00d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa908f8d9ddde01136c44a0f09fb00d5">&#9670;&nbsp;</a></span>g() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01253">1253</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1254</span>                                                              {</div>
<div class="line"><span class="lineno"> 1255</span>                        <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.g;</div>
<div class="line"><span class="lineno"> 1256</span>                      }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ae3ac9c7640e303e5020ccea0eaf0dfb7" name="ae3ac9c7640e303e5020ccea0eaf0dfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ac9c7640e303e5020ccea0eaf0dfb7">&#9670;&nbsp;</a></span>g() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the control transition matrix G. </p>
<p >This member function is not present when the filter has no input.</p>
<dl class="section return"><dt>Returns</dt><dd>The control transition matrix G.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01240">1240</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1241</span>                                                                    {</div>
<div class="line"><span class="lineno"> 1242</span>                              <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.g;</div>
<div class="line"><span class="lineno"> 1243</span>                            }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a3de41e564a10050c0fd7be455045bba6" name="a3de41e564a10050c0fd7be455045bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de41e564a10050c0fd7be455045bba6">&#9670;&nbsp;</a></span>g() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; <br />
requires (not std::is_same_v&lt;Input, void&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the control transition matrix G. </p>
<p >This member function is not present when the filter has no input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied control transition matrix G.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01263">1263</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1265</span>{</div>
<div class="line"><span class="lineno"> 1266</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.g = value;</div>
<div class="line"><span class="lineno"> 1267</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a8f81d84c28af1605363ed9812028dc41" name="a8f81d84c28af1605363ed9812028dc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f81d84c28af1605363ed9812028dc41">&#9670;&nbsp;</a></span>g() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">transition_control_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the control transition matrix G function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the control transition matrix G on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01285">1285</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1286</span>                                                       {</div>
<div class="line"><span class="lineno"> 1287</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition_control_g = callable;</div>
<div class="line"><span class="lineno"> 1288</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ad3e3d62942b259c347fc03e232f2c297" name="ad3e3d62942b259c347fc03e232f2c297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e3d62942b259c347fc03e232f2c297">&#9670;&nbsp;</a></span>g() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; <br />
requires (not std::is_same_v&lt;Input, void&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a59c62d02fbc8be939e05a135b0cec3b8">input_control</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the control transition matrix G. </p>
<p >This member function is not present when the filter has no input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved control transition matrix G.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01274">1274</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1276</span>{</div>
<div class="line"><span class="lineno"> 1277</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.g = std::move(value);</div>
<div class="line"><span class="lineno"> 1278</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a7c1c1eb68626e399abf117de538c254b" name="a7c1c1eb68626e399abf117de538c254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c1eb68626e399abf117de538c254b">&#9670;&nbsp;</a></span>g() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a78b78edf59992eb0f70a5ac7e929435e">transition_control_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the control transition matrix G function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the control transition matrix G on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01295">1295</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1296</span>                                                        {</div>
<div class="line"><span class="lineno"> 1297</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition_control_g = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1298</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a6b74778e3d98fafca60b81b71669d178" name="a6b74778e3d98fafca60b81b71669d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b74778e3d98fafca60b81b71669d178">&#9670;&nbsp;</a></span>h() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01193">1193</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1193</span>                                                          {</div>
<div class="line"><span class="lineno"> 1194</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.h;</div>
<div class="line"><span class="lineno"> 1195</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a2a696e4880433cce993a10b19887747b" name="a2a696e4880433cce993a10b19887747b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a696e4880433cce993a10b19887747b">&#9670;&nbsp;</a></span>h() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the observation transition matrix H. </p>
<dl class="section return"><dt>Returns</dt><dd>The observation, measurement transition matrix H.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01183">1183</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1183</span>                                                                      {</div>
<div class="line"><span class="lineno"> 1184</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.h;</div>
<div class="line"><span class="lineno"> 1185</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a18f2040d7e00b06874e5a4ff7bb3385f" name="a18f2040d7e00b06874e5a4ff7bb3385f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f2040d7e00b06874e5a4ff7bb3385f">&#9670;&nbsp;</a></span>h() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">observation_state_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation, measurement transition matrix H function. </p>
<p >For non-linear system, or extended filter, H is the Jacobian of the state observation function: <code>H = ∂h/∂X = ∂hj/∂xi</code> that is each row i contains the derivatives of the state observation function for every element j in the state column vector X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the observation, measurement transition matrix H on update steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01220">1220</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1221</span>                                                       {</div>
<div class="line"><span class="lineno"> 1222</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.observation_state_h = callable;</div>
<div class="line"><span class="lineno"> 1223</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ae4f7ba705650fe606d346969b4542461" name="ae4f7ba705650fe606d346969b4542461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f7ba705650fe606d346969b4542461">&#9670;&nbsp;</a></span>h() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation transition matrix H. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied observation transition matrix H.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01202">1202</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1202</span>                                                                 {</div>
<div class="line"><span class="lineno"> 1203</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.h = value;</div>
<div class="line"><span class="lineno"> 1204</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a03d83761a97e6908465a75da1e2ee4da" name="a03d83761a97e6908465a75da1e2ee4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d83761a97e6908465a75da1e2ee4da">&#9670;&nbsp;</a></span>h() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1985c7ac691e33223b6b470bd7516056">observation_state_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation, measurement transition matrix H function. </p>
<p >For non-linear system, or extended filter, H is the Jacobian of the state observation function: <code>H = ∂h/∂X = ∂hj/∂xi</code> that is each row i contains the derivatives of the state observation function for every element j in the state column vector X.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the observation, measurement transition matrix H on update steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01230">1230</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1230</span>                                                                             {</div>
<div class="line"><span class="lineno"> 1231</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.observation_state_h = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1232</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ae3890f39ad42f502ced221c523589fb5" name="ae3890f39ad42f502ced221c523589fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3890f39ad42f502ced221c523589fb5">&#9670;&nbsp;</a></span>h() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1642332d5ad9d1e135bbe5220961de64">output_model</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation transition matrix H. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved observation transition matrix H.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01211">1211</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1211</span>                                                            {</div>
<div class="line"><span class="lineno"> 1212</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.h = std::move(value);</div>
<div class="line"><span class="lineno"> 1213</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a9ab8dd1a980bb6a0ec2527ccc0b6370d" name="a9ab8dd1a980bb6a0ec2527ccc0b6370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab8dd1a980bb6a0ec2527ccc0b6370d">&#9670;&nbsp;</a></span>k()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::k</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gain matrix K. </p>
<dl class="section return"><dt>Returns</dt><dd>The gain matrix K.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01306">1306</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1306</span>                                                              {</div>
<div class="line"><span class="lineno"> 1307</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.k;</div>
<div class="line"><span class="lineno"> 1308</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a8322a989123873c88190f4dd7cea40a5" name="a8322a989123873c88190f4dd7cea40a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8322a989123873c88190f4dd7cea40a5">&#9670;&nbsp;</a></span>observation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::observation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">observation_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the extended state observation function h(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called to compute the observation Z on update steps. The default function <code>h(x) = H * X</code> is suitable for linear systems. For non-linear system, or extended filter, the client implements a linearization of the observation function hand the state observation H matrix is the Jacobian of the state observation function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01356">1356</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1357</span>                                                                 {</div>
<div class="line"><span class="lineno"> 1358</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.observation = callable;</div>
<div class="line"><span class="lineno"> 1359</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a2eee8dab54e2cf6b78bf52551c988bf5" name="a2eee8dab54e2cf6b78bf52551c988bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee8dab54e2cf6b78bf52551c988bf5">&#9670;&nbsp;</a></span>observation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::observation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a689fcc450a7698b5375da9dc9c6a535b">observation_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the extended state observation function h(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called to compute the observation Z on update steps. The default function <code>h(x) = H * X</code> is suitable for linear systems. For non-linear system, or extended filter, the client implements a linearization of the observation function hand the state observation H matrix is the Jacobian of the state observation function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01366">1366</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1367</span>                                                                  {</div>
<div class="line"><span class="lineno"> 1368</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.observation = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1369</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a4ae5a09664832ca35039c426a4a15cc6" name="a4ae5a09664832ca35039c426a4a15cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae5a09664832ca35039c426a4a15cc6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p >Destroys or copy-assigns the contents with a copy of the contents of the other filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object filter parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa2f0430be3a57809a6bdca479c341954" name="aa2f0430be3a57809a6bdca479c341954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f0430be3a57809a6bdca479c341954">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p >Replaces the contents of the filter with those of the <code>other</code> filter using move semantics (i.e. the data in <code>other</code> filter is moved from the other into this filter). The other filter is in a valid but unspecified state afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object filter parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a9742852191b4bb4397e77ffbffafde42" name="a9742852191b4bb4397e77ffbffafde42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9742852191b4bb4397e77ffbffafde42">&#9670;&nbsp;</a></span>p() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00984">984</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  984</span>                                                                  {</div>
<div class="line"><span class="lineno">  985</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.p;</div>
<div class="line"><span class="lineno">  986</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ac86b75da175dc0a7ac9eec5803c92f4b" name="ac86b75da175dc0a7ac9eec5803c92f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86b75da175dc0a7ac9eec5803c92f4b">&#9670;&nbsp;</a></span>p() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the estimated covariance matrix P. </p>
<dl class="section return"><dt>Returns</dt><dd>The estimated correlated variance matrix P.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00973">973</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  974</span>                                    {</div>
<div class="line"><span class="lineno">  975</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.p;</div>
<div class="line"><span class="lineno">  976</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a922687019e99df6169eb09ddaa396bd7" name="a922687019e99df6169eb09ddaa396bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922687019e99df6169eb09ddaa396bd7">&#9670;&nbsp;</a></span>p() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the estimated covariance matrix P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied estimated covariance matrix P.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00993">993</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  993</span>                                                                         {</div>
<div class="line"><span class="lineno">  994</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.p = value;</div>
<div class="line"><span class="lineno">  995</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ac5cb329547421eabc8bb91f2c16329b7" name="ac5cb329547421eabc8bb91f2c16329b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cb329547421eabc8bb91f2c16329b7">&#9670;&nbsp;</a></span>p() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a15928894f06259752d02d9ee26b2e47e">estimate_uncertainty</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the estimated covariance matrix P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved estimated covariance matrix P.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01002">1002</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1002</span>                                                                    {</div>
<div class="line"><span class="lineno"> 1003</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.p = std::move(value);</div>
<div class="line"><span class="lineno"> 1004</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="aec1d96672e7eea0d0b7c53c21eaf6f90" name="aec1d96672e7eea0d0b7c53c21eaf6f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1d96672e7eea0d0b7c53c21eaf6f90">&#9670;&nbsp;</a></span>predict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<div class="memtemplate">
template&lt;std::size_t Position&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::predict</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Nth prediction argument. </p>
<p >Convenience access to the last used prediction arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>non-type template parameter index position of the prediction argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prediction argument corresponding to the Nth position of the parameter pack of the tuple-like <code>PredictionTypes</code> class template type.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01407">1407</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1407</span>                                                    {</div>
<div class="line"><span class="lineno"> 1408</span>  <span class="keywordflow">return</span> std::get&lt;Position&gt;(<a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.prediction_arguments);</div>
<div class="line"><span class="lineno"> 1409</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a326b305473fba0a1efc17660c94eb199" name="a326b305473fba0a1efc17660c94eb199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326b305473fba0a1efc17660c94eb199">&#9670;&nbsp;</a></span>predict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::predict </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces estimates of the state variables and uncertainties. </p>
<p >Implements the total probability theorem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>The prediction and input parameters of the filter, in that order. The arguments need to be compatible with the filter types. The prediction parameters convertible to the <code>PredictionTypes</code> template pack types are passed through for computations of prediction matrices. The control parameter pack types convertible to the <code>Input</code> template type. The prediction types are explicitly defined with the class definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000022">Todo:</a></b></dt><dd><p class="startdd">Consider if returning the state column vector X would be preferable? Or fluent interface? Would be compatible with an ES-EKF implementation? </p>
<p class="enddd">Can the parameter pack of <code>PredictionTypes</code> be explicit in the method declaration for user clarity? </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01396">1396</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1396</span>                                                                      {</div>
<div class="line"><span class="lineno"> 1397</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.predict(arguments...);</div>
<div class="line"><span class="lineno"> 1398</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

<p class="reference">Referenced by <a class="el" href="eigen__predict__x1x_8cpp_source.xhtml#l00058">fcarouge::eigen::benchmark::eigen_predict()</a>, <a class="el" href="predict__1x1x0_8cpp_source.xhtml#l00050">fcarouge::benchmark::anonymous_namespace{predict_1x1x0.cpp}::predict_1x1x0()</a>, and <a class="el" href="predict__1x1x1_8cpp_source.xhtml#l00051">fcarouge::benchmark::anonymous_namespace{predict_1x1x1.cpp}::predict_1x1x1()</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classfcarouge_1_1kalman_a326b305473fba0a1efc17660c94eb199_icgraph.svg" width="403" height="242"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afb00b60a769d35cb1bb343f759e36143" name="afb00b60a769d35cb1bb343f759e36143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb00b60a769d35cb1bb343f759e36143">&#9670;&nbsp;</a></span>q() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01022">1022</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1022</span>                                                                 {</div>
<div class="line"><span class="lineno"> 1023</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.q;</div>
<div class="line"><span class="lineno"> 1024</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a39949781d9f392007b6dbf97d7b5bcab" name="a39949781d9f392007b6dbf97d7b5bcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39949781d9f392007b6dbf97d7b5bcab">&#9670;&nbsp;</a></span>q() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the process noise covariance matrix Q. </p>
<dl class="section return"><dt>Returns</dt><dd>The process noise correlated variance matrix Q.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01012">1012</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1012</span>                                                                             {</div>
<div class="line"><span class="lineno"> 1013</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.q;</div>
<div class="line"><span class="lineno"> 1014</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ab318abf09d9bdc76f8b620a005bf89df" name="ab318abf09d9bdc76f8b620a005bf89df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab318abf09d9bdc76f8b620a005bf89df">&#9670;&nbsp;</a></span>q() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">noise_process_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the process noise covariance matrix Q function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the process noise covariance matrix Q on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01049">1049</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1050</span>                                                       {</div>
<div class="line"><span class="lineno"> 1051</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.noise_process_q = callable;</div>
<div class="line"><span class="lineno"> 1052</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a83e4f8a0a73353e11ddebbd1b8d1d82f" name="a83e4f8a0a73353e11ddebbd1b8d1d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e4f8a0a73353e11ddebbd1b8d1d82f">&#9670;&nbsp;</a></span>q() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the process noise covariance matrix Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied process noise covariance matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01031">1031</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1031</span>                                                                        {</div>
<div class="line"><span class="lineno"> 1032</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.q = value;</div>
<div class="line"><span class="lineno"> 1033</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a0b29b04611a007b055c3b79c5df93bc3" name="a0b29b04611a007b055c3b79c5df93bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b29b04611a007b055c3b79c5df93bc3">&#9670;&nbsp;</a></span>q() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a7bbfed3fa165990b1d2b11b66a8ce5c2">noise_process_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the process noise covariance matrix Q function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to the prediction arguments and called by the filter to compute the process noise covariance matrix Q on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01059">1059</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1059</span>                                                                         {</div>
<div class="line"><span class="lineno"> 1060</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.noise_process_q = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1061</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a3e5dbe4814f6b42a296c23498010d37f" name="a3e5dbe4814f6b42a296c23498010d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5dbe4814f6b42a296c23498010d37f">&#9670;&nbsp;</a></span>q() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a95e201e1563f135b128edbf2c9793e56">process_uncertainty</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the process noise covariance matrix Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved process noise covariance matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01040">1040</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1040</span>                                                                   {</div>
<div class="line"><span class="lineno"> 1041</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.q = std::move(value);</div>
<div class="line"><span class="lineno"> 1042</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="aac11636c2f58e37be2f4c6d90a8f1bfa" name="aac11636c2f58e37be2f4c6d90a8f1bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac11636c2f58e37be2f4c6d90a8f1bfa">&#9670;&nbsp;</a></span>r() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01079">1079</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1079</span>                                                                {</div>
<div class="line"><span class="lineno"> 1080</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.r;</div>
<div class="line"><span class="lineno"> 1081</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="ad36f348f6a553a23e0ea60be43d70f6a" name="ad36f348f6a553a23e0ea60be43d70f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36f348f6a553a23e0ea60be43d70f6a">&#9670;&nbsp;</a></span>r() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the observation noise covariance matrix R. </p>
<p >The variance there is in each measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>The observation noise correlated variance matrix R.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01069">1069</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1069</span>                                                                            {</div>
<div class="line"><span class="lineno"> 1070</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.r;</div>
<div class="line"><span class="lineno"> 1071</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a1d5e5a551e56582d41d2291f68ec85ef" name="a1d5e5a551e56582d41d2291f68ec85ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5e5a551e56582d41d2291f68ec85ef">&#9670;&nbsp;</a></span>r() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">noise_observation_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation noise covariance matrix R function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called by the filter to compute the observation noise covariance matrix R on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01106">1106</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1107</span>                                                       {</div>
<div class="line"><span class="lineno"> 1108</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.noise_observation_r = callable;</div>
<div class="line"><span class="lineno"> 1109</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a2817f91f637370aea02b56fbf076fa01" name="a2817f91f637370aea02b56fbf076fa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2817f91f637370aea02b56fbf076fa01">&#9670;&nbsp;</a></span>r() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation noise covariance matrix R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied observation noise covariance matrix R.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01088">1088</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1088</span>                                                                       {</div>
<div class="line"><span class="lineno"> 1089</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.r = value;</div>
<div class="line"><span class="lineno"> 1090</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a476a5222f56e85a2a03b3de5f735952a" name="a476a5222f56e85a2a03b3de5f735952a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a5222f56e85a2a03b3de5f735952a">&#9670;&nbsp;</a></span>r() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1f72ebc552d798c0f1c20198e68127bc">noise_observation_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation noise covariance matrix R function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called by the filter to compute the observation noise covariance matrix R on prediction steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01116">1116</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1116</span>                                                                             {</div>
<div class="line"><span class="lineno"> 1117</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.noise_observation_r = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1118</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="aa0619da7600a0124f811314fd2021815" name="aa0619da7600a0124f811314fd2021815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0619da7600a0124f811314fd2021815">&#9670;&nbsp;</a></span>r() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a9fac97289314ad4018774b6afbd73716">output_uncertainty</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the observation noise covariance matrix R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved observation noise covariance matrix R.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01097">1097</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1097</span>                                                                  {</div>
<div class="line"><span class="lineno"> 1098</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.r = std::move(value);</div>
<div class="line"><span class="lineno"> 1099</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a0828a776eb386c75dfda49b963b9bd25" name="a0828a776eb386c75dfda49b963b9bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0828a776eb386c75dfda49b963b9bd25">&#9670;&nbsp;</a></span>s()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::s</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the innovation uncertainty matrix S. </p>
<dl class="section return"><dt>Returns</dt><dd>The innovation uncertainty matrix S.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01326">1326</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1327</span>                                      {</div>
<div class="line"><span class="lineno"> 1328</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.s;</div>
<div class="line"><span class="lineno"> 1329</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a3d730d7d70675193158ca059a41ffde0" name="a3d730d7d70675193158ca059a41ffde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d730d7d70675193158ca059a41ffde0">&#9670;&nbsp;</a></span>transition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">transition_function</a> &amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the extended state transition function f(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The copied target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called to compute the next state X on prediction steps. The default function <code>f(x) = F * X</code> is suitable for linear systems. For non-linear system, or extended filter, implement a linearization of the transition function f and the state transition F matrix is the Jacobian of the state transition function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01336">1336</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1337</span>                                                                {</div>
<div class="line"><span class="lineno"> 1338</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition = callable;</div>
<div class="line"><span class="lineno"> 1339</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a79c28d25749406338e2895dbad5c0158" name="a79c28d25749406338e2895dbad5c0158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c28d25749406338e2895dbad5c0158">&#9670;&nbsp;</a></span>transition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a590bb0d2390025d6e1705dd073450bf8">transition_function</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the extended state transition function f(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>The moved target Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be called to compute the next state X on prediction steps. The default function <code>f(x) = F * X</code> is suitable for linear systems. For non-linear system, or extended filter, implement a linearization of the transition function f and the state transition F matrix is the Jacobian of the state transition function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01346">1346</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1347</span>                                                                 {</div>
<div class="line"><span class="lineno"> 1348</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.transition = std::forward&lt;decltype(callable)&gt;(callable);</div>
<div class="line"><span class="lineno"> 1349</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a219ab6c9d08b0b4b6928363a370fb2c5" name="a219ab6c9d08b0b4b6928363a370fb2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219ab6c9d08b0b4b6928363a370fb2c5">&#9670;&nbsp;</a></span>u()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last control column vector U. </p>
<p >This member function is not present when the filter has no input.</p>
<dl class="section return"><dt>Returns</dt><dd>The last control column vector U.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00960">960</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  961</span>                                                            {</div>
<div class="line"><span class="lineno">  962</span>                      <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.u;</div>
<div class="line"><span class="lineno">  963</span>                    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a8bb0ab5cffd71944ac83f19d5f3b3c83" name="a8bb0ab5cffd71944ac83f19d5f3b3c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb0ab5cffd71944ac83f19d5f3b3c83">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<div class="memtemplate">
template&lt;std::size_t Position&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::update</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Nth update argument. </p>
<p >Convenience access to the last used update arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>non-type template parameter index position of the update argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update argument corresponding to the Nth position of the parameter pack of the tuple-like <code>UpdateTypes</code> class template type.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01387">1387</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1387</span>                                                   {</div>
<div class="line"><span class="lineno"> 1388</span>  <span class="keywordflow">return</span> std::get&lt;Position&gt;(<a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.update_arguments);</div>
<div class="line"><span class="lineno"> 1389</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a71b11bb6c9a898533dfd86ce6eef5c20" name="a71b11bb6c9a898533dfd86ce6eef5c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b11bb6c9a898533dfd86ce6eef5c20">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the estimates with the outcome of a measurement. </p>
<p >Also known as the observation or correction step. Implements the Bayes' theorem. Combine one measurement and the prior estimate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>The update and output parameters of the filter, in that order. The arguments need to be compatible with the filter types. The update parameters convertible to the <code>UpdateTypes</code> template pack types are passed through for computations of update matrices. The observation parameter pack types convertible to the <code>Output</code> template type. The update types are explicitly defined with the class definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000023">Todo:</a></b></dt><dd><p class="startdd">Consider if returning the state column vector X would be preferable? Or fluent interface? Would be compatible with an ES-EKF implementation? </p>
<p class="enddd">Can the parameter pack of <code>UpdateTypes</code> be explicit in the method declaration for user clarity? </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01376">1376</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1376</span>                                                                     {</div>
<div class="line"><span class="lineno"> 1377</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.update(arguments...);</div>
<div class="line"><span class="lineno"> 1378</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

<p class="reference">Referenced by <a class="el" href="eigen__update__xx0_8cpp_source.xhtml#l00058">fcarouge::eigen::benchmark::eigen_update()</a>, <a class="el" href="update__1x1x0_8cpp_source.xhtml#l00051">fcarouge::benchmark::anonymous_namespace{update_1x1x0.cpp}::update_1x1x0()</a>, and <a class="el" href="update__1x1x1_8cpp_source.xhtml#l00051">fcarouge::benchmark::anonymous_namespace{update_1x1x1.cpp}::update_1x1x1()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classfcarouge_1_1kalman_a71b11bb6c9a898533dfd86ce6eef5c20_icgraph.svg" width="446" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4651ec960a279b0d44df09278ce7f452" name="a4651ec960a279b0d44df09278ce7f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4651ec960a279b0d44df09278ce7f452">&#9670;&nbsp;</a></span>x() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00902">902</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  902</span>                                                   {</div>
<div class="line"><span class="lineno">  903</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x;</div>
<div class="line"><span class="lineno">  904</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a283ddb031438dc6b3a9f7c6cadf09338" name="a283ddb031438dc6b3a9f7c6cadf09338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283ddb031438dc6b3a9f7c6cadf09338">&#9670;&nbsp;</a></span>x() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the state estimate column vector X. </p>
<dl class="section return"><dt>Returns</dt><dd>The state estimate column vector X.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Overloading the operator dot would have been nice had it existed.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000020">Todo:</a></b></dt><dd>Collapse cv-ref qualifier-aware member functions per C++23 P0847 to avoid duplication: <code>inline constexpr auto &amp; x(this auto&amp;&amp; self)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00892">892</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  892</span>                                                               {</div>
<div class="line"><span class="lineno">  893</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x;</div>
<div class="line"><span class="lineno">  894</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a04f87358de723f8ae31cd0098b54feeb" name="a04f87358de723f8ae31cd0098b54feeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f87358de723f8ae31cd0098b54feeb">&#9670;&nbsp;</a></span>x() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state estimate column vector X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The first moved initializer used to set the state estimate column vector X. </td></tr>
    <tr><td class="paramname">values</td><td>The second and other moved initializers to set the state estimate column vector X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00939">939</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  939</span>                                                                      {</div>
<div class="line"><span class="lineno">  940</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x = std::move(<a class="code hl_typedef" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a>{std::forward&lt;decltype(value)&gt;(value),</div>
<div class="line"><span class="lineno">  941</span>                             std::forward&lt;decltype(values)&gt;(values)...});</div>
<div class="line"><span class="lineno">  942</span>}</div>
<div class="ttc" id="aclassfcarouge_1_1kalman_xhtml_a1102f87212b368e4e55bcd5d637a600c"><div class="ttname"><a href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">fcarouge::kalman::state</a></div><div class="ttdeci">typename implementation::state state</div><div class="ttdoc">Type of the state estimate column vector X.</div><div class="ttdef"><b>Definition:</b> <a href="kalman_8hpp_source.xhtml#l00230">kalman.hpp:230</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a232d3cdfe6af3eed0cfe3bbfc1a6a51b" name="a232d3cdfe6af3eed0cfe3bbfc1a6a51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232d3cdfe6af3eed0cfe3bbfc1a6a51b">&#9670;&nbsp;</a></span>x() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state estimate column vector X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The first copied initializer used to set the state estimate column vector X. </td></tr>
    <tr><td class="paramname">values</td><td>The second and other copied initializers to set the state estimate column vector X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00929">929</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  930</span>                                                               {</div>
<div class="line"><span class="lineno">  931</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x = std::move(<a class="code hl_typedef" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a>{value, values...});</div>
<div class="line"><span class="lineno">  932</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a7f45fec5e2a499c7874350f27ff16959" name="a7f45fec5e2a499c7874350f27ff16959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f45fec5e2a499c7874350f27ff16959">&#9670;&nbsp;</a></span>x() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state estimate column vector X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The copied state estimate column vector X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00911">911</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  911</span>                                                          {</div>
<div class="line"><span class="lineno">  912</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x = value;</div>
<div class="line"><span class="lineno">  913</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a0c655b621eaaea59e65cce6abe12dbd7" name="a0c655b621eaaea59e65cce6abe12dbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c655b621eaaea59e65cce6abe12dbd7">&#9670;&nbsp;</a></span>x() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml#a1102f87212b368e4e55bcd5d637a600c">state</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state estimate column vector X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The moved state estimate column vector X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00920">920</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  920</span>                                                     {</div>
<div class="line"><span class="lineno">  921</span>  <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.x = std::move(value);</div>
<div class="line"><span class="lineno">  922</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a768f798cf2e400312f713434fca71adb" name="a768f798cf2e400312f713434fca71adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768f798cf2e400312f713434fca71adb">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the innovation column vector Y. </p>
<dl class="section return"><dt>Returns</dt><dd>The innovation column vector Y.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l01316">1316</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1316</span>                                                                    {</div>
<div class="line"><span class="lineno"> 1317</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.y;</div>
<div class="line"><span class="lineno"> 1318</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<a id="a9171abacab66f3af260de6de99790298" name="a9171abacab66f3af260de6de99790298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9171abacab66f3af260de6de99790298">&#9670;&nbsp;</a></span>z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Output , typename Input , typename Transpose , typename Symmetrize , typename Divide , typename Identity , typename UpdateTypes , typename PredictionTypes &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::z</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last observation column vector Z. </p>
<dl class="section return"><dt>Returns</dt><dd>The last observation column vector Z.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00950">950</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  950</span>                                                                {</div>
<div class="line"><span class="lineno">  951</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classfcarouge_1_1kalman.xhtml#a642727d695ea4a1fee490ff7dd6ad7f8">filter</a>.z;</div>
<div class="line"><span class="lineno">  952</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kalman_8hpp_source.xhtml#l00221">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a642727d695ea4a1fee490ff7dd6ad7f8" name="a642727d695ea4a1fee490ff7dd6ad7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642727d695ea4a1fee490ff7dd6ad7f8">&#9670;&nbsp;</a></span>filter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State  = double, typename Output  = double, typename Input  = void, typename Transpose  = std::identity, typename Symmetrize  = std::identity, typename Divide  = std::divides&lt;void&gt;, typename Identity  = identity_matrix, typename UpdateTypes  = empty_pack, typename PredictionTypes  = empty_pack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1kalman.xhtml#ab36b602d354fad0d0d0aa93abcdd9f01">implementation</a> <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encapsulates the implementation details of the filter. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00221">221</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="kalman_8hpp_source.xhtml#l01126">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::f()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01240">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::g()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01183">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::h()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01306">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::k()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01356">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::observation()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l00973">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::p()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01396">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::predict()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01012">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::q()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01069">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::r()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01326">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::s()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01336">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::transition()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l00960">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::u()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01376">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::update()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l00892">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::x()</a>, <a class="el" href="kalman_8hpp_source.xhtml#l01316">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::y()</a>, and <a class="el" href="kalman_8hpp_source.xhtml#l00950">fcarouge::kalman&lt; State, Output, Input, Transpose, Symmetrize, Divide, Identity, UpdateTypes, PredictionTypes &gt;::z()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/fcarouge/internal/<a class="el" href="format_8hpp_source.xhtml">format.hpp</a></li>
<li>include/fcarouge/<a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefcarouge.xhtml">fcarouge</a></li><li class="navelem"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a></li>
    <li class="footer">Generated on Sun Sep 25 2022 05:28:55 for Kalman by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
