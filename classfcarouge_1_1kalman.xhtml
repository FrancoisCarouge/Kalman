<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kalman: fcarouge::kalman&lt; typename &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kalman<span id="projectnumber">&#160;0.5.3</span>
   </div>
   <div id="projectbrief">Kalman Filter</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classfcarouge_1_1kalman.xhtml',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classfcarouge_1_1kalman-members.xhtml">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fcarouge::kalman&lt; typename &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A generic Kalman filter.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for fcarouge::kalman&lt; typename &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classfcarouge_1_1kalman__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for fcarouge::kalman&lt; typename &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classfcarouge_1_1kalman__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a414b735bdd80f9ca5120d6abe6284fe8" id="r_a414b735bdd80f9ca5120d6abe6284fe8"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:a414b735bdd80f9ca5120d6abe6284fe8"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a414b735bdd80f9ca5120d6abe6284fe8">kalman</a> (Arguments... arguments)</td></tr>
<tr class="memdesc:a414b735bdd80f9ca5120d6abe6284fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a Kalman filter from its declared configuration.  <br /></td></tr>
<tr class="separator:a414b735bdd80f9ca5120d6abe6284fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413e9589c51e5234e547106382dd6afd" id="r_a413e9589c51e5234e547106382dd6afd"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413e9589c51e5234e547106382dd6afd">kalman</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;other)=default</td></tr>
<tr class="memdesc:a413e9589c51e5234e547106382dd6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs a filter.  <br /></td></tr>
<tr class="separator:a413e9589c51e5234e547106382dd6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2291a1d9bd4cc169f91e9b10399b38" id="r_a0c2291a1d9bd4cc169f91e9b10399b38"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2291a1d9bd4cc169f91e9b10399b38">kalman</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a0c2291a1d9bd4cc169f91e9b10399b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs a filter.  <br /></td></tr>
<tr class="separator:a0c2291a1d9bd4cc169f91e9b10399b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b99418f893adb28768ee33b72ef84" id="r_a7f6b99418f893adb28768ee33b72ef84"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f6b99418f893adb28768ee33b72ef84">operator=</a> (const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;other) -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td></tr>
<tr class="memdesc:a7f6b99418f893adb28768ee33b72ef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a7f6b99418f893adb28768ee33b72ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5d074d54a2a6e9713f2cb5c23643c9" id="r_a3b5d074d54a2a6e9713f2cb5c23643c9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b5d074d54a2a6e9713f2cb5c23643c9">operator=</a> (<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td></tr>
<tr class="memdesc:a3b5d074d54a2a6e9713f2cb5c23643c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a3b5d074d54a2a6e9713f2cb5c23643c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb20ca92a3ba1b0d82ea7d3edf54fe4" id="r_aefb20ca92a3ba1b0d82ea7d3edf54fe4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb20ca92a3ba1b0d82ea7d3edf54fe4">~kalman</a> ()=default</td></tr>
<tr class="memdesc:aefb20ca92a3ba1b0d82ea7d3edf54fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the Kalman filter.  <br /></td></tr>
<tr class="separator:aefb20ca92a3ba1b0d82ea7d3edf54fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Characteristics Member Functions</div></td></tr>
<tr class="memitem:ae1e817e346030c859b125e55b01958b8" id="r_ae1e817e346030c859b125e55b01958b8"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e817e346030c859b125e55b01958b8">x</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:ae1e817e346030c859b125e55b01958b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the estimated state column vector X.  <br /></td></tr>
<tr class="separator:ae1e817e346030c859b125e55b01958b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7559b050bd3397cd9a19177183897d90" id="r_a7559b050bd3397cd9a19177183897d90"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7559b050bd3397cd9a19177183897d90">z</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a7559b050bd3397cd9a19177183897d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the observation column vector Z.  <br /></td></tr>
<tr class="separator:a7559b050bd3397cd9a19177183897d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39502e666ec9b275dff79cab8d80cc0a" id="r_a39502e666ec9b275dff79cab8d80cc0a"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39502e666ec9b275dff79cab8d80cc0a">u</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a39502e666ec9b275dff79cab8d80cc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the control column vector U.  <br /></td></tr>
<tr class="separator:a39502e666ec9b275dff79cab8d80cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dfd1f36f26d2704609142ba22e21d3" id="r_a45dfd1f36f26d2704609142ba22e21d3"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45dfd1f36f26d2704609142ba22e21d3">p</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a45dfd1f36f26d2704609142ba22e21d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the estimated covariance matrix P.  <br /></td></tr>
<tr class="separator:a45dfd1f36f26d2704609142ba22e21d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e6cb7cd0947e7fd667b355b6d1bc62" id="r_a56e6cb7cd0947e7fd667b355b6d1bc62"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56e6cb7cd0947e7fd667b355b6d1bc62">q</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a56e6cb7cd0947e7fd667b355b6d1bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the process noise covariance matrix or function Q.  <br /></td></tr>
<tr class="separator:a56e6cb7cd0947e7fd667b355b6d1bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50f7dd74a3403b1654b288dc503e78c" id="r_af50f7dd74a3403b1654b288dc503e78c"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af50f7dd74a3403b1654b288dc503e78c">r</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:af50f7dd74a3403b1654b288dc503e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the observation noise covariance matrix R.  <br /></td></tr>
<tr class="separator:af50f7dd74a3403b1654b288dc503e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b8d7b910747e12e2b0bd9e3ffd7f01" id="r_ae5b8d7b910747e12e2b0bd9e3ffd7f01"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b8d7b910747e12e2b0bd9e3ffd7f01">f</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:ae5b8d7b910747e12e2b0bd9e3ffd7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the state transition matrix F.  <br /></td></tr>
<tr class="separator:ae5b8d7b910747e12e2b0bd9e3ffd7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620f13a8d1e6d7d682ef490a20ea1056" id="r_a620f13a8d1e6d7d682ef490a20ea1056"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a620f13a8d1e6d7d682ef490a20ea1056">h</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a620f13a8d1e6d7d682ef490a20ea1056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the observation transition matrix H.  <br /></td></tr>
<tr class="separator:a620f13a8d1e6d7d682ef490a20ea1056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448582dd24cd3ba5ebb86689c1cb5567" id="r_a448582dd24cd3ba5ebb86689c1cb5567"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448582dd24cd3ba5ebb86689c1cb5567">g</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:a448582dd24cd3ba5ebb86689c1cb5567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the control transition matrix G.  <br /></td></tr>
<tr class="separator:a448582dd24cd3ba5ebb86689c1cb5567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09b35535cde173f24fbc874c356078b" id="r_ad09b35535cde173f24fbc874c356078b"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09b35535cde173f24fbc874c356078b">k</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:ad09b35535cde173f24fbc874c356078b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the gain matrix K.  <br /></td></tr>
<tr class="separator:ad09b35535cde173f24fbc874c356078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff6ca7f13df7de09378ab8d07d2ae9e" id="r_acff6ca7f13df7de09378ab8d07d2ae9e"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff6ca7f13df7de09378ab8d07d2ae9e">y</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:acff6ca7f13df7de09378ab8d07d2ae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the innovation column vector Y.  <br /></td></tr>
<tr class="separator:acff6ca7f13df7de09378ab8d07d2ae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8625f2929750982f82d0ef9e0f8fd" id="r_ab6f8625f2929750982f82d0ef9e0f8fd"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6f8625f2929750982f82d0ef9e0f8fd">s</a> (this auto &amp;&amp;self, const auto &amp;...values)</td></tr>
<tr class="memdesc:ab6f8625f2929750982f82d0ef9e0f8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read, write the innovation uncertainty matrix S.  <br /></td></tr>
<tr class="separator:ab6f8625f2929750982f82d0ef9e0f8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Filtering Member Functions</div></td></tr>
<tr class="memitem:aa64cb12fb86876fb5bf74555b8b67f5a" id="r_aa64cb12fb86876fb5bf74555b8b67f5a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa64cb12fb86876fb5bf74555b8b67f5a">predict</a> (const auto &amp;...arguments)</td></tr>
<tr class="memdesc:aa64cb12fb86876fb5bf74555b8b67f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces estimates of the state variables and uncertainties.  <br /></td></tr>
<tr class="separator:aa64cb12fb86876fb5bf74555b8b67f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ffdc102439da5653543ad51291406e" id="r_a85ffdc102439da5653543ad51291406e"><td class="memTemplParams" colspan="2">template&lt;auto Position&gt; </td></tr>
<tr class="memitem:a85ffdc102439da5653543ad51291406e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85ffdc102439da5653543ad51291406e">predict</a> () const</td></tr>
<tr class="memdesc:a85ffdc102439da5653543ad51291406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Nth prediction argument.  <br /></td></tr>
<tr class="separator:a85ffdc102439da5653543ad51291406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9f5770f213ef92663c25c1db743f98" id="r_a5a9f5770f213ef92663c25c1db743f98"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9f5770f213ef92663c25c1db743f98">update</a> (const auto &amp;...arguments)</td></tr>
<tr class="memdesc:a5a9f5770f213ef92663c25c1db743f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the estimates with the outcome of a measurement.  <br /></td></tr>
<tr class="separator:a5a9f5770f213ef92663c25c1db743f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f8830ac8d109d2685b187bca02e4f8" id="r_a26f8830ac8d109d2685b187bca02e4f8"><td class="memTemplParams" colspan="2">template&lt;auto Position&gt; </td></tr>
<tr class="memitem:a26f8830ac8d109d2685b187bca02e4f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26f8830ac8d109d2685b187bca02e4f8">update</a> () const</td></tr>
<tr class="memdesc:a26f8830ac8d109d2685b187bca02e4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Nth update argument.  <br /></td></tr>
<tr class="separator:a26f8830ac8d109d2685b187bca02e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:ac639e5ff752f6598318aa36d93526ea5" id="r_ac639e5ff752f6598318aa36d93526ea5"><td class="memItemLeft" align="right" valign="top">Filter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac639e5ff752f6598318aa36d93526ea5">filter</a></td></tr>
<tr class="memdesc:ac639e5ff752f6598318aa36d93526ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the implementation details of the filter.  <br /></td></tr>
<tr class="separator:ac639e5ff752f6598318aa36d93526ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename&gt;<br />
class fcarouge::kalman&lt; typename &gt;</div><p>A generic Kalman filter. </p>
<p>The Kalman filter is a Bayesian filter that uses multivariate Gaussians, a recursive state estimator, a linear quadratic estimator (LQE), and an Infinite Impulse Response (IIR) filter. It is a control theory tool applicable to signal estimation, sensor fusion, or data assimilation problems. The filter is applicable for unimodal and uncorrelated uncertainties. The filter assumes white noise, propagation and measurement functions are differentiable, and that the uncertainty stays centered on the state estimate. The filter is the optimal linear filter under assumptions. The filter updates estimates by multiplying Gaussians and predicts estimates by adding Gaussians. Designing a filter is as much art as science. Design the state $X$, $P$, the process $F$, $Q$, the measurement $Z$, $R$, the measurement function $H$, and if the system has control inputs $U$, $G$.</p>
<p>This library supports various simple and extended filters. The implementation is independent from linear algebra backends. Arbitrary parameters can be added to the prediction and update stages to participate in gain-scheduling or linear parameter varying (LPV) systems. The default filter type is a generalized, customizable, and extended filter. The default type parameters implement a one-state, one-output, and double-precision floating-point type filter. The default update equation uses the Joseph form. Examples illustrate various usages and implementation tradeoffs. A standard formatter specialization is included for representation of the filter states. Filters with <code>state x output x input</code> dimensions as 1x1x1 and 1x1x0 (no input) are supported through vanilla C++. Higher dimension filters require a linear algebra backend. Customization points and type injections allow for implementation tradeoffs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Filter</td><td>Exposition only. The deduced internal filter template parameter. Class template argument deduction (CTAD) figures out the filter type based on the declared configuration. See deduction guide. The internal implementation, filtering strategies, and presence of members vary based on the constructed, configured, declared, or deduced filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000008">Todo</a></b></dt><dd><p class="startdd">Make this class usable in constant expressions. </p>
<p class="interdd">Is this filter restricted to Newton's equations of motion? That is only a discretized continuous-time kinematic filter? How about non-Newtonian systems? </p>
<p class="interdd">Symmetrization support might be superfluous. How to confirm it is safe to remove? Optional? </p>
<p class="interdd">Would we want to support smoothers? </p>
<p class="interdd">Prepare support for larger dataset recording for graphing, metrics of large test data to facilitate tuning. </p>
<p class="interdd">Support filter generator from equation? Third party integration? </p>
<p class="interdd">Compare performance of general filter with its equivalent generated? </p>
<p class="interdd">Support ranges operator filter? </p>
<p class="interdd">Support mux pipes <a href="https://github.com/joboccara/pipes">https://github.com/joboccara/pipes</a> operator filter? </p>
<p class="interdd">Reproduce Ardupilot's inertial navigation EKF and comparison benchmarks in SITL (software in the loop simulation). </p>
<p class="interdd">Should we provide the operator[] for the vector characteristics regardless of implementation? And for the matrix ones too? It could simplify client code. </p>
<p class="interdd">Should we provide the operator[] for state directly on the filter? Is the state X always what the user would want? </p>
<p class="interdd">Support, test complex number filters? </p>
<p class="interdd">Use automatic (Eigen::AutoDiffScalar?), symbolic, numerical solvers to define the filter characteristics and simplify solving the dynamic system for non-mathematicians. </p>
<p class="interdd">Should we add back the call operator? How to resolve the update/predict ordering? And parameter ordering? </p>
<p class="interdd">Should we support the noise cross covariance <code>N = E[wvᵀ]</code> for correlated noise sources, with default to null? </p>
<p class="enddd">Can we implement Temporal Parallelization of Bayesian Smoothers, Simo Sarkka, Senior Member, IEEE, Angel F. Garc ıa-Fernandez, <a href="https://arxiv.org/pdf/1905.13002.pdf">https://arxiv.org/pdf/1905.13002.pdf</a> ? GPU implementation? Parallel implementation? </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="kalman__forward_8hpp_source.xhtml#l00049">49</a> of file <a class="el" href="kalman__forward_8hpp_source.xhtml">kalman_forward.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a414b735bdd80f9ca5120d6abe6284fe8" name="a414b735bdd80f9ca5120d6abe6284fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414b735bdd80f9ca5120d6abe6284fe8">&#9670;&#160;</a></span>kalman() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::kalman </td>
          <td>(</td>
          <td class="paramtype">Arguments...</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a Kalman filter from its declared configuration. </p>
<dl class="section see"><dt>See also</dt><dd>Deduction guide for details.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a413e9589c51e5234e547106382dd6afd" name="a413e9589c51e5234e547106382dd6afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413e9589c51e5234e547106382dd6afd">&#9670;&#160;</a></span>kalman() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::kalman </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; typename &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs a filter. </p>
<p>Copy constructor. Constructs the filter with the contents of the <code>other</code> filter using copy semantics (i.e. the data in <code>other</code> filter is copied from the other into this filter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a0c2291a1d9bd4cc169f91e9b10399b38" name="a0c2291a1d9bd4cc169f91e9b10399b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2291a1d9bd4cc169f91e9b10399b38">&#9670;&#160;</a></span>kalman() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::kalman </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; typename &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs a filter. </p>
<dl class="section warning"><dt>Warning</dt><dd>Some filter types have a known move memory safety defect.</dd></dl>
<p>Move constructor. Constructs the filter with the contents of the <code>other</code> filter using move semantics (i.e. the data in <code>other</code> filter is moved from the other into this filter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aefb20ca92a3ba1b0d82ea7d3edf54fe4" name="aefb20ca92a3ba1b0d82ea7d3edf54fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb20ca92a3ba1b0d82ea7d3edf54fe4">&#9670;&#160;</a></span>~kalman()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::~<a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the Kalman filter. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5b8d7b910747e12e2b0bd9e3ffd7f01" name="ae5b8d7b910747e12e2b0bd9e3ffd7f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b8d7b910747e12e2b0bd9e3ffd7f01">&#9670;&#160;</a></span>f()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::f </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the state transition matrix F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the state transition matrix F characteristic. The characteristic may also be a callable of the form <code>state_transition(const state &amp;, const input ! &amp;, const PredictionTypes &amp;...)</code>. For non-linear system, or extended filter, F is the Jacobian of the state transition function: <code>F = ∂f/∂X = ! ∂fj/∂xi</code> that is each row i contains the derivatives of the state transition function for every element j in the state column vector X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a448582dd24cd3ba5ebb86689c1cb5567" name="a448582dd24cd3ba5ebb86689c1cb5567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448582dd24cd3ba5ebb86689c1cb5567">&#9670;&#160;</a></span>g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::g </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the control transition matrix G. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the control transition matrix G. characteristic. The characteristic may also be a callable of the form <code>input_control(const PredictionTypes &amp;...)</code>. This member function is not present when the filter has no input control.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a620f13a8d1e6d7d682ef490a20ea1056" name="a620f13a8d1e6d7d682ef490a20ea1056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620f13a8d1e6d7d682ef490a20ea1056">&#9670;&#160;</a></span>h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::h </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the observation transition matrix H. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the observation transition matrix H characteristic. The characteristic may also be a callable of the form <code>output_model(const state &amp;, const UpdateTypes ! &amp;...)</code>. For non-linear system, or extended filter, H is the Jacobian of the state observation function: <code>H = ∂h/∂X = ∂hj/∂xi</code> that is each row i contains the derivatives of the state observation function for every element j in the state column vector X. This member function is not present when the filter has no output model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="ad09b35535cde173f24fbc874c356078b" name="ad09b35535cde173f24fbc874c356078b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09b35535cde173f24fbc874c356078b">&#9670;&#160;</a></span>k()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::k </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the gain matrix K. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the gain matrix K characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a7f6b99418f893adb28768ee33b72ef84" name="a7f6b99418f893adb28768ee33b72ef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b99418f893adb28768ee33b72ef84">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; typename &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents of the filter with those of the <code>other</code> filter using copy semantics (i.e. the data in <code>other</code> filter is copied from the other into this filter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object filter parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a3b5d074d54a2a6e9713f2cb5c23643c9" name="a3b5d074d54a2a6e9713f2cb5c23643c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5d074d54a2a6e9713f2cb5c23643c9">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a>&lt; typename &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section warning"><dt>Warning</dt><dd>Some filter types have a known move memory safety defect.</dd></dl>
<p>Replaces the contents of the filter with those of the <code>other</code> filter using move semantics (i.e. the data in <code>other</code> filter is moved from the other into this filter). The other filter is in a valid but unspecified state afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another filter to be used as source to initialize the elements of the filter with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object filter parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a45dfd1f36f26d2704609142ba22e21d3" name="a45dfd1f36f26d2704609142ba22e21d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dfd1f36f26d2704609142ba22e21d3">&#9670;&#160;</a></span>p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::p </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the estimated covariance matrix P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the estimated covariance matrix P characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a85ffdc102439da5653543ad51291406e" name="a85ffdc102439da5653543ad51291406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ffdc102439da5653543ad51291406e">&#9670;&#160;</a></span>predict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<div class="memtemplate">
template&lt;auto Position&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::predict </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Nth prediction argument. </p>
<p>Convenience access to the last used prediction arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>non-type template parameter index position of the prediction argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prediction argument corresponding to the Nth position of the parameter pack of the tuple <code>PredictionTypes</code> class template type.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa64cb12fb86876fb5bf74555b8b67f5a" name="aa64cb12fb86876fb5bf74555b8b67f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64cb12fb86876fb5bf74555b8b67f5a">&#9670;&#160;</a></span>predict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::predict </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces estimates of the state variables and uncertainties. </p>
<p>Also known as the propagation step. Implements the total probability theorem. Estimate the next state by suming the known probabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>The prediction and input parameters of the filter, in that order. The arguments need to be compatible with the filter types. The prediction parameters convertible to the <code>PredictionTypes</code> template pack types are passed through for computations of prediction matrices. The control parameter pack types convertible to the <code>Input</code> template type. The prediction types are explicitly defined with the class definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000017">Todo</a></b></dt><dd><p class="startdd">Consider if returning the state column vector X would be preferable? Or fluent interface? Would be compatible with an ES-EKF implementation? </p>
<p class="enddd">Can the parameter pack of <code>PredictionTypes</code> be explicit in the method declaration for user clarity? </p>
</dd></dl>

</div>
</div>
<a id="a56e6cb7cd0947e7fd667b355b6d1bc62" name="a56e6cb7cd0947e7fd667b355b6d1bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e6cb7cd0947e7fd667b355b6d1bc62">&#9670;&#160;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::q </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the process noise covariance matrix or function Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the process noise covariance matrix Q characteristic. The characteristic may also be a callable of the form <code>process_uncertainty(const state &amp;, const ! PredictionTypes &amp;...)</code>. <pre class="fragment">  \par Complexity
  Constant. 
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af50f7dd74a3403b1654b288dc503e78c" name="af50f7dd74a3403b1654b288dc503e78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50f7dd74a3403b1654b288dc503e78c">&#9670;&#160;</a></span>r()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::r </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the observation noise covariance matrix R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the observation noise covariance matrix R characteristic. The characteristic may also be a callable of the form <code>output_uncertainty(const state &amp;, const output &amp;, ! const UpdateTypes &amp;...)</code>. <pre class="fragment">  \par Complexity
  Constant. 
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6f8625f2929750982f82d0ef9e0f8fd" name="ab6f8625f2929750982f82d0ef9e0f8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f8625f2929750982f82d0ef9e0f8fd">&#9670;&#160;</a></span>s()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::s </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the innovation uncertainty matrix S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the innovation uncertainty matrix S characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a39502e666ec9b275dff79cab8d80cc0a" name="a39502e666ec9b275dff79cab8d80cc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39502e666ec9b275dff79cab8d80cc0a">&#9670;&#160;</a></span>u()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::u </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the control column vector U. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the control column vector U characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a26f8830ac8d109d2685b187bca02e4f8" name="a26f8830ac8d109d2685b187bca02e4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f8830ac8d109d2685b187bca02e4f8">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<div class="memtemplate">
template&lt;auto Position&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::update </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Nth update argument. </p>
<p>Convenience access to the last used update arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>non-type template parameter index position of the update argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update argument corresponding to the Nth position of the parameter pack of the tuple <code>UpdateTypes</code> class template type.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a5a9f5770f213ef92663c25c1db743f98" name="a5a9f5770f213ef92663c25c1db743f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9f5770f213ef92663c25c1db743f98">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the estimates with the outcome of a measurement. </p>
<p>Also known as the observation or correction step. Implements the Bayes' theorem. Combine one measurement and the prior estimate by applying the multiplicative law.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>The update and output parameters of the filter, in that order. The arguments need to be compatible with the filter types. The update parameters convertible to the <code>UpdateTypes</code> template pack types are passed through for computations of update matrices. The observation parameter pack types convertible to the <code>Output</code> template type. The update types are explicitly defined with the class definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.xhtml#_todo000021">Todo</a></b></dt><dd><p class="startdd">Consider if returning the state column vector X would be preferable? Or fluent interface? Would be compatible with an ES-EKF implementation? </p>
<p class="enddd">Can the parameter pack of <code>UpdateTypes</code> be explicit in the method declaration for user clarity? </p>
</dd></dl>

</div>
</div>
<a id="ae1e817e346030c859b125e55b01958b8" name="ae1e817e346030c859b125e55b01958b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e817e346030c859b125e55b01958b8">&#9670;&#160;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::x </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the estimated state column vector X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the estimated state column vector X characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="acff6ca7f13df7de09378ab8d07d2ae9e" name="acff6ca7f13df7de09378ab8d07d2ae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff6ca7f13df7de09378ab8d07d2ae9e">&#9670;&#160;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::y </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the innovation column vector Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the innovation column vector Y characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a7559b050bd3397cd9a19177183897d90" name="a7559b050bd3397cd9a19177183897d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7559b050bd3397cd9a19177183897d90">&#9670;&#160;</a></span>z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::z </td>
          <td>(</td>
          <td class="paramtype">this auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;...</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read, write the observation column vector Z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Explicit object parameter. Internal implementation detail. </td></tr>
    <tr><td class="paramname">values</td><td>The optional copied initializers to set the observation column vector Z characteristic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac639e5ff752f6598318aa36d93526ea5" name="ac639e5ff752f6598318aa36d93526ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639e5ff752f6598318aa36d93526ea5">&#9670;&#160;</a></span>filter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Filter <a class="el" href="classfcarouge_1_1kalman.xhtml">fcarouge::kalman</a>&lt; typename &gt;::filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encapsulates the implementation details of the filter. </p>
<p>Optionally exposes a variety of members and methods according to the selected implementation. </p>

<p class="definition">Definition at line <a class="el" href="kalman_8hpp_source.xhtml#l00136">136</a> of file <a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/github/workspace/include/fcarouge/<a class="el" href="kalman_8hpp_source.xhtml">kalman.hpp</a></li>
<li>/github/workspace/include/fcarouge/<a class="el" href="kalman__forward_8hpp_source.xhtml">kalman_forward.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefcarouge.xhtml">fcarouge</a></li><li class="navelem"><a class="el" href="classfcarouge_1_1kalman.xhtml">kalman</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
